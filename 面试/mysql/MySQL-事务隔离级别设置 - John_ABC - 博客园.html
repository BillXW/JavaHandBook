<!DOCTYPE html>
<!-- saved from url=(0046)https://www.cnblogs.com/JohnABC/p/3521061.html -->
<html lang="zh-cn"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="referrer" content="never">
    <title>MySQL-事务隔离级别设置 - John_ABC - 博客园</title>
<meta property="og:description" content="加锁研究:http://www.cnblogs.com/JohnABC/p/4377529.html 先了解下 第一类丢失更新、脏读、不可重复读、幻读、第二类丢失更新 第一类丢失更新 撤销一个事务时,">
    <link type="text/css" rel="stylesheet" href="./MySQL-事务隔离级别设置 - John_ABC - 博客园_files/blog-common.css">
<link id="MainCss" type="text/css" rel="stylesheet" href="./MySQL-事务隔离级别设置 - John_ABC - 博客园_files/bundle-AnotherEon001.css">
<link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="./MySQL-事务隔离级别设置 - John_ABC - 博客园_files/bundle-AnotherEon001-mobile.css">
    <link title="RSS" type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/JohnABC/rss">
    <link title="RSD" type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/JohnABC/rsd.xml">
<link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/JohnABC/wlwmanifest.xml">
    <script src="./MySQL-事务隔离级别设置 - John_ABC - 博客园_files/osd.js.下载"></script><script src="./MySQL-事务隔离级别设置 - John_ABC - 博客园_files/amp4ads-host-v0.js.下载"></script><script src="./MySQL-事务隔离级别设置 - John_ABC - 博客园_files/pubads_impl_rendering_308.js.下载"></script><script async="" src="./MySQL-事务隔离级别设置 - John_ABC - 博客园_files/analytics.js.下载"></script><script type="text/javascript" src="./MySQL-事务隔离级别设置 - John_ABC - 博客园_files/encoder.js.下载"></script><script src="./MySQL-事务隔离级别设置 - John_ABC - 博客园_files/jquery-2.2.0.min.js.下载"></script>
    <script>var currentBlogId=156331;var currentBlogApp='JohnABC',cb_enable_mathjax=false;var isLogined=false;</script>
    <script src="./MySQL-事务隔离级别设置 - John_ABC - 博客园_files/blog-common.js.下载" type="text/javascript"></script>
<link rel="preload" href="./MySQL-事务隔离级别设置 - John_ABC - 博客园_files/f.txt" as="script"><script type="text/javascript" src="./MySQL-事务隔离级别设置 - John_ABC - 博客园_files/f.txt"></script><script src="./MySQL-事务隔离级别设置 - John_ABC - 博客园_files/pubads_impl_308.js.下载" async=""></script><link rel="prefetch" href="https://tpc.googlesyndication.com/safeframe/1-0-32/html/container.html"></head>
<body>
<a name="top"></a>


<div id="wrapper">
<div id="header">

<div id="top">
<h1><a id="Header1_HeaderTitle" class="headermaintitle" href="https://www.cnblogs.com/JohnABC/">John_ABC</a></h1>
<div id="subtitle">毅力~</div>
</div>
<div id="sub"><div id="blog_stats">
<div class="BlogStats">随笔 - 416, 文章 - 0, 评论 - 21, 引用 - 0</div>
</div></div>



</div>
<div id="main_container">
<div id="main_content">
<div id="content">
	
        <div id="post_detail">
	<div class="post">
		<h2>
			<a id="cb_post_title_url" href="https://www.cnblogs.com/JohnABC/p/3521061.html">MySQL-事务隔离级别设置</a>
		</h2>
		<div class="postbody">
		<div id="cnblogs_post_body" class="blogpost-body"><p><span style="font-size: 14px;">加锁研究:<a href="http://www.cnblogs.com/JohnABC/p/4377529.html" target="_blank">http://www.cnblogs.com/JohnABC/p/4377529.html</a></span></p>
<p><span style="font-size: 14px;">先了解下 第一类丢失更新、<span style="color: #ff0000;"><strong>脏读、不可重复读、幻读</strong></span>、第二类丢失更新</span></p>
<p><strong><span style="font-size: 14px;">第一类丢失更新</span></strong></p>
<p><span style="font-size: 14px;">撤销一个事务时, 把其他事务已经提交的更新数据覆盖(此情况在事务中不可能出现, 因为一个事务中修改时此记录已加锁, 必须等待此事务完成后另一个事务才可以继续UPDATE)</span></p>
<p><strong><span style="font-size: 14px;">脏读</span></strong></p>
<p><span style="font-size: 14px;"><span style="color: #ff0000;">一个事务读到另一个事务，尚未提交的修改，就是脏读</span>。这里所谓的修改，除了Update操作,不要忘了,还包括</span><span style="font-size: 14px;">Insert和Delete操作。</span><span style="font-size: 14px;">脏读的后果：如果后一个事务回滚，那么它所做的修改，统统都会被撤销。前一个事务读到的数据，就是垃圾数据。</span></p>
<p><span style="font-size: 14px;">举个例子：预订房间。</span></p>
<p><span style="font-size: 14px;">有一张Reservation表，往表中插入一条记录，来订购一个房间。</span></p>
<p><span style="font-size: 14px;">事务1：在Reservation表中插入一条记录，用于预订99号房间。</span></p>
<p><span style="font-size: 14px;">事务2：查询，尚未预定的房间列表，因为99号房间，已经被事务1预订。所以不在列表中。</span></p>
<p><span style="font-size: 14px;">事务1：信用卡付款。由于付款失败，导致整个事务回滚。 </span><span style="font-size: 14px;">所以插入到Reservation 表中的记录并不置为持久（即它将被删除）。</span></p>
<p><span style="font-size: 14px;">现在99号房间则为可用。</span></p>
<p><span style="font-size: 14px;">所以，事务2所用的是一个无效的房间列表，因为99号房间，已经可用。如果它是最后一个没有被预定的房间，那么这将是一个严重的失误。</span></p>
<p><span style="font-size: 14px;">注：脏读的后果很严重。</span></p>
<p><span style="font-size: 14px;">再例如</span></p>
<table style="width: 80%;" border="1" cellspacing="1" cellpadding="1">
<tbody>
<tr>
<td>时间</td>
<td>取款事务</td>
<td>支票转账事务</td>
</tr>
<tr>
<td>T1</td>
<td>开始事务</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>T2</td>
<td>&nbsp;</td>
<td>开始事务</td>
</tr>
<tr>
<td>T3</td>
<td>查询账户余额为1000元</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>T4</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>T5</td>
<td>取出100，把存款余额改为900元</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>T6</td>
<td>&nbsp;</td>
<td>查询账户的存款余额为900元（脏读）</td>
</tr>
<tr>
<td>T7</td>
<td>撤销该事务，把存款余额恢复为1000元</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>T8</td>
<td>&nbsp;</td>
<td>汇入100元，把存款余额改为1000元</td>
</tr>
<tr>
<td>T9</td>
<td>&nbsp;</td>
<td>提交事务</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p><span style="font-size: 14px;"><strong>不可重复读</strong></span></p>
<p><span style="font-size: 14px;">在同一个事务中，再次读取数据时【就是你的select操作】，所读取的数据，和第1次读取的数据，不一样了。就是不可重复读。</span></p>
<p><span style="font-size: 14px;">举个例子：</span></p>
<p><span style="font-size: 14px;">事务1：查询有双人床房间。99号房间，有双人床。</span></p>
<p><span style="font-size: 14px;">事务2：将99号房间，改成单人床房间。</span></p>
<p><span style="font-size: 14px;">事务1：再次执行查询，请求所有双人床房间列表，99号房间不再列表中了。也就是说，</span><span style="font-size: 14px;">事务1，可以看到其他事务所做的修改。</span></p>
<p><span style="font-size: 14px;">在不可重复读，里面，可以看到其他事务所做的修改，而导致2次的查询结果不再一样了。</span><span style="font-size: 14px;">这里的修改，是提交过的。也可以是没有提交的，这种情况同时也是脏读。</span></p>
<p><span style="font-size: 14px;">如果，数据库系统的隔离级别。允许，不可重复读。那么你启动一个事务，并做一个select查询操作。</span><span style="font-size: 14px;">查询到的数据，就有可能，和你第2次，3次...n次，查询到的数据不一样。一般情况下，你只会做一次，select</span><br><span style="font-size: 14px;">
查询，并以这一次的查询数据，作为后续计算的基础。因为允许出现，不可重复读。那么任何</span><span style="font-size: 14px;">时候，查询到的数据，都有可能被其他事务更新，查询的结果将是不确定的。</span></p>
<p><span style="font-size: 14px;">注：如果允许，不可重复读，你的查询结果，将是不确定的。一个不确定的结果，你能容忍吗？</span></p>
<p><strong><span style="font-size: 14px;">幻读</span></strong> </p>
<p><span style="font-size: 14px;">事务1读取指定的where子句所返回的一些行。然后，事务2插入一个新行，这个新行也满足事务1使用的查询</span><span style="font-size: 14px;">where子句。然后事务1再次使用相同的查询读取行，但是现在它看到了事务2刚插入的行。这个行被称为幻象，</span><span style="font-size: 14px;">因为对事务1来说，这一行的出现是不可思议的。</span></p>
<p><span style="font-size: 14px;">举个例子：</span></p>
<p><span style="font-size: 14px;">事务1：请求没有预定的，双人床房间列表。</span></p>
<p><span style="font-size: 14px;">事务2：向Reservation表中插入一个新纪录，以预订99号房间，并提交。</span></p>
<p><span style="font-size: 14px;">事务1：再次请求有双人床的未预定的房间列表，99号房间，不再位于列表中。</span></p>
<p><span style="font-size: 14px;">注：幻读，针对的是，Insert操作。如果事务2，插入的记录，没有提交。那么同时也是脏读。</span></p>
<p><strong><span style="font-size: 14px;"><span style="font-size: 14px;">第二类丢失更新</span></span></strong></p>
<p><span style="font-size: 14px;"><span style="font-size: 14px;">这是不可重复读中的特例, 一个事务覆盖另一个事务已提交的更新数据(以下会出现此情况)</span></span></p>
<table style="width: 80%;" border="1" cellspacing="1" cellpadding="1">
<tbody>
<tr>
<td>时间</td>
<td>取款事务</td>
<td>支票转账事务</td>







</tr>
<tr>
<td>T1</td>
<td>开始事务</td>
<td>&nbsp;</td>







</tr>
<tr>
<td>T2</td>
<td>&nbsp;</td>
<td>开始事务</td>







</tr>
<tr>
<td>T3</td>
<td>查询账户余额为1000元</td>
<td>&nbsp;</td>







</tr>
<tr>
<td>T4</td>
<td>&nbsp;</td>
<td>查询账户余额为1000元</td>







</tr>
<tr>
<td>T5</td>
<td>取出100，把存款余额改为900元</td>
<td>&nbsp;</td>







</tr>
<tr>
<td>T6</td>
<td>提交事务</td>
<td>&nbsp;</td>







</tr>
<tr>
<td>T7</td>
<td>&nbsp;</td>
<td>汇入100元，把存款余额改为1100元</td>







</tr>
<tr>
<td>T8</td>
<td>&nbsp;</td>
<td>提交事务</td>







</tr>







</tbody>







</table>
<p>&nbsp;</p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody>
<tr>
<td>No</td>
<td>事务1</td>
<td>事务2</td>
<td>备注</td>




</tr>
<tr>
<td>1</td>
<td> select * from tb2 where id=1;<br>
&lt;NO&gt; &nbsp; &nbsp;id &nbsp; &nbsp; &nbsp;name &nbsp; &nbsp;name2<br>
1 &nbsp; &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp; a &nbsp; &nbsp; &nbsp; a<br>
			</td>
<td>
				<br>
			</td>
<td>
				<br>
			</td>






		</tr>
<tr>
<td>
				2
			</td>
<td>
				<br>
			</td>
<td>
				update tb2 set name2='b'&nbsp;where id=1;<br>
1 Rows updated!<br>
			</td>
<td>
				<br>
			</td>






		</tr>
<tr>
<td>
				3
			</td>
<td>
				select * from tb2&nbsp;where id=1;<br>
&lt;NO&gt; &nbsp; &nbsp;id &nbsp; &nbsp; &nbsp;name &nbsp; &nbsp;name2<br>
1 &nbsp; &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp; a &nbsp; &nbsp; &nbsp; a<br>
			</td>
<td>
				<br>
			</td>
<td>
				很好:没有出现脏读
			</td>






		</tr>
<tr>
<td>
				4
			</td>
<td>
				<br>
			</td>
<td>
				commit
			</td>
<td>
				<br>
			</td>






		</tr>
<tr>
<td>
				5
			</td>
<td>
				select * from tb2 where id=1;<br>
&lt;NO&gt; &nbsp; &nbsp;id &nbsp; &nbsp; &nbsp;name &nbsp; &nbsp;name2<br>
1 &nbsp; &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp; a &nbsp; &nbsp; &nbsp; a<br>
			</td>
<td>
				<br>
			</td>
<td>
				很好:没有出现不可重复读
			</td>






		</tr>
<tr>
<td>
				6
			</td>
<td>
				update tb2 set name='a1'&nbsp;where id=1;<br>
1 Rows updated!<br>
			</td>
<td>
				<br>
			</td>
<td>
				<br>
			</td>






		</tr>
<tr>
<td>
				7
			</td>
<td>
				select * from tb2 where id=1;<br>
&lt;NO&gt; &nbsp; &nbsp;id &nbsp; &nbsp; &nbsp;name &nbsp; &nbsp;name2<br>
1 &nbsp; &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp; a1 &nbsp; &nbsp; &nbsp;b<br>
			</td>
<td>
				<br>
			</td>
<td>
				<strong><span style="color: #e53333; font-size: 16px;">糟糕</span></strong><span style="font-size: 16px;">:name2的值怎么跟以前不一样了。(即出现了不可重复读) 
			</span></td>






		</tr>
<tr>
<td>
				8
			</td>
<td>
				commit
			</td>
<td>
				<br>
			</td>
<td>&nbsp;</td>





</tr>





</tbody>




</table>
<p>&nbsp;</p>
<p>应该明白 <span style="color: #ff0000;"><strong>什么状况对什么加什么锁(可以分别思考和测试每个隔离级别下脏读、不可重复读、幻读的出现及不出现原因)</strong></span></p>
<p>读完下面的内容可以回头来看此段:</p>
<p>　　不可重复读错误处理:通常可以用&nbsp;set&nbsp;tran&nbsp;isolation&nbsp;level&nbsp;repeatable&nbsp;read&nbsp;来设置隔离级别, 这样事务 A&nbsp;在两次读取表T中的数据时, 事务B如果企图更改表T中的数据（细节到事务A读取数据）时, 就会被阻塞, 直到事务A提交！&nbsp;这样就保证了, 事务A两次读取的数据的一致性</p>
<p>　　幻读错误处理:如果设置&nbsp;repeatable&nbsp;read, 虽然可以防止事务B对数据进行修改, 但是事务B却可以向表T中插入新的数据, 如何防止这个问题, 我们可以考虑设置最高的事务隔离级别&nbsp;set&nbsp;tran&nbsp;isolation&nbsp;level&nbsp;serializable, 于是乎, 事务B就只能乖乖的等待事务A的提交, 才能向表T中插入新的数据, 从而避免了幻读</p>
<p>&nbsp;</p>
<p><strong>不可重复读与幻读的区别:</strong></p>
<p><span style="color: #ff0000;">脏读的重点是读另一个事务未提交的数据(假若那个事务RollBack, 则这数据就是无效的):<span style="font-size: 14px;">某个事务已更新一份数据, 另一个事务在此时读取了同一份数据, 由于某些原因, 前一个RollBack了操作, 则后一个事务所读取的数据就会是不正确的</span></span></p>
<p><span style="color: #ff0000;">不可重复读的重点是修改: 同样的条件,&nbsp;你读取过的数据,&nbsp;再次读取出来发现值不一样了</span></p>
<p><span style="color: #ff0000;">幻读的重点在于新增或者删除: 同样的条件,&nbsp;第1次和第2次读出来的记录数不一样</span></p>
<p><span style="color: #ff0000;">当然,&nbsp;从总的结果来看,&nbsp;似乎两者都表现为两次读取的结果不一致, 但如果你从控制的角度来看,&nbsp;两者的区别就比较大, 对于不可重复读,&nbsp;只需要锁住满足条件的记录, 对于幻读,&nbsp;要锁住满足条件及其相近的记录</span></p>
<p>&nbsp;</p>
<p><span style="color: #ff0000;"><strong>rollback;或者commit;都会退出事务！</strong></span> </p>
<p><strong><span style="color: #ff0000;">更新记录的时候需要锁！</span></strong></p>
<p>&nbsp;</p>
<p><span style="color: #ff0000;"><strong>InnoDB中 只要此行在别的事务中产生了锁 本事务中就不允许进行修改 只能阻塞 等待别的事务提交</strong></span></p>
<p>&nbsp;</p>
<p><strong><span style="color: #ff0000;">一般设置为Read Committed, 并且利用悲观锁(SELECT ... FOR UPDATE)或乐观锁(SET NUM=NUM+1, 而不是计算后再插入, 避免并发)来处理特殊</span></strong>情况 </p>
<p>&nbsp;</p>
<p><span style="font-size: 14px;">SQL标准定义了4类隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。<br><strong>Read Uncommitted（读取未提交内容）</strong>
</span></p>
<p><span style="font-size: 14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。<br><strong>Read Committed（读取提交内容）</strong>

</span></p>
<p><span style="font-size: 14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别
也支持所谓的不可重复读（Nonrepeatable 
Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。<br><strong>Repeatable Read（可重读）</strong>

</span></p>
<p><span style="font-size: 14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读
（Phantom 
Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影”
行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency 
Control）机制解决了该问题。
</span></p>
<p><span style="font-size: 14px;"><strong>Serializable（可串行化）</strong>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。<strong><span style="color: #ff0000;">只要操作产生了锁，就不允许其他事务读取和修改！(可以看看加锁处理分析<a href="http://hedengcheng.com/?p=771" target="_blank">http://hedengcheng.com/?p=771</a>或者百度网盘<a href="http://pan.baidu.com/s/1mgN00Og" target="_blank">http://pan.baidu.com/s/1mgN00Og</a>)</span></strong></span></p>
<p><span style="font-size: 14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这四种隔离级别采取不同的锁类型来实现，若读取的是同一个数据的话，就容易发生问题。例如：
</span></p>
<p><span style="font-size: 14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。
</span></p>
<p><span style="font-size: 14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。
</span></p>
<p><span style="font-size: 14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。
</span></p>
<p><span style="font-size: 14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在MySQL中，实现了这四种隔离级别，分别有可能产生问题如下所示：</span></p>
<p style="text-align: center;"><span style="font-size: 14px;"><img class="magplus" style="vertical-align: middle;" title="点击查看原始大小图片" src="./MySQL-事务隔离级别设置 - John_ABC - 博客园_files/af5b9c1e-4517-3df2-ad62-af25d1672d12.jpg" alt="" width="700" height="223"></span></p>
<table style="width: 80%;" border="1" cellspacing="1" cellpadding="1">
<tbody>
<tr>
<td>隔离级别</td>
<td>是否出现第一类丢失更新</td>
<td>是否出现脏读</td>
<td>是否出现不可重复读</td>
<td>是否出现幻读</td>
<td>是否出现第二类丢失更新</td>





</tr>
<tr>
<td>Serializable</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>否</td>





</tr>
<tr>
<td>Repeatable Read</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>是</td>
<td>否</td>





</tr>
<tr>
<td>Read Commited</td>
<td>否</td>
<td>否</td>
<td>是</td>
<td>是</td>
<td>是</td>





</tr>
<tr>
<td>Read Uncommited</td>
<td>否</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>是</td>





</tr>





</tbody>





</table>
<p><span style="font-size: 14px;"><br>
</span></p>
<p><span style="font-size: 14px;">下面，将利用MySQL的客户端程序，分别测试几种隔离级别。测试数据库为test，表为tx；表结构：
</span></p>
<table style="height: 50px; width: 440px;" border="0">
<tbody>
<tr>
<td style="text-align: center;"><span style="font-size: 14px;">
id
</span></td>
<td><span style="font-size: 14px;">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int
</span></td>




























</tr>
<tr>
<td>
<p style="text-align: center;"><span style="font-size: 14px;">num
</span></p>




























</td>
<td><span style="font-size: 14px;">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int
</span></td>




























</tr>




























</tbody>



























</table>
<p><span style="font-size: 14px;">两个命令行客户端分别为A，B；不断改变A的隔离级别，在B端修改数据。
</span></p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">SET</span> <span style="color: #ff0000;">[</span><span style="color: #ff0000;">SESSION|GLOBAL</span><span style="color: #ff0000;">]</span> <span style="color: #0000ff;">TRANSACTION</span> <span style="color: #0000ff;">ISOLATION</span> <span style="color: #0000ff;">LEVEL</span> <span style="color: #ff0000;">[</span><span style="color: #ff0000;">READ UNCOMMITTED|READ COMMITTED|REPEATABLE READ|SERIALIZABLE</span><span style="color: #ff0000;">]</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: 14px;"><strong>（一）、将A的隔离级别设置为read uncommitted(未提交读) </strong> </span></p>
<p><span style="font-size: 14px;">&nbsp;在B未更新数据之前： </span></p>
<p><span style="font-size: 14px;"><strong>客户端A： </strong> <img src="./MySQL-事务隔离级别设置 - John_ABC - 博客园_files/1ca8ec0d-3b6c-3ae1-babc-5dd541c4d1a4.jpg" alt="" width="645" height="379"></span></p>
<p><span style="font-size: 14px;"> B更新数据： </span></p>
<p><span style="font-size: 14px;"><strong>客户端B： </strong> </span></p>
<p><span style="font-size: 14px;"><img src="./MySQL-事务隔离级别设置 - John_ABC - 博客园_files/b37214c3-7726-3306-95ee-1b2fae5ccd6c.jpg" alt="" width="640" height="397"></span></p>
<p><span style="font-size: 14px;"><strong>客户端A： </strong> </span></p>
<p style="text-align: left;"><span style="font-size: 14px;"><img src="./MySQL-事务隔离级别设置 - John_ABC - 博客园_files/200d9c94-197a-3fe5-8925-3411cd88555e.jpg" alt="" width="640" height="481"></span></p>
<p><span style="font-size: 14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 经过上面的实验可以得出结论，事务B更新了一条记录，但是没有提交，此时事务A可以查询出未提交记录。造成脏读现象。未提交读是最低的隔离级别。 </span></p>
<p><span style="font-size: 14px;"><strong>（二）、将客户端A的事务隔离级别设置为read committed(已提交读) </strong> </span></p>
<p><span style="font-size: 14px;">&nbsp;在B未更新数据之前： </span></p>
<p><span style="font-size: 14px;"> <strong>客户端A： </strong></span></p>
<p><span style="font-size: 14px;"><a class="underline" href="http://xm-king.iteye.com/upload/picture/pic/72626/ae414e52-c216-3bbb-b005-0d972f593456.jpg"><img src="./MySQL-事务隔离级别设置 - John_ABC - 博客园_files/ae414e52-c216-3bbb-b005-0d972f593456.jpg" alt="" width="644" height="351"></a> </span></p>
<p><span style="font-size: 14px;"> B更新数据： </span></p>
<p><span style="font-size: 14px;"><strong>客户端B： </strong> </span></p>
<p><span style="font-size: 14px;"><img src="./MySQL-事务隔离级别设置 - John_ABC - 博客园_files/12051f3d-c01e-34b3-a6b6-8b71e1b1dcc8.jpg" alt="" width="641" height="313"></span></p>
<p><span style="font-size: 14px;"><strong>客户端A： </strong> </span></p>
<p><span style="font-size: 14px;"><img src="./MySQL-事务隔离级别设置 - John_ABC - 博客园_files/cc80744e-eb9f-3104-bb24-2218e9986d78.jpg" alt="" width="642" height="351"></span></p>
<p><span style="font-size: 14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 经过上面的实验可以得出结论，已提交读隔离级别解决了脏读的问题，但是出现了不可重复读的问题，即事务A在两次查询的数据不一致，因为在两次查询之间事务B更新了一条数据。已提交读只允许读取已提交的记录，但不要求可重复读。 </span></p>
<p><span style="font-size: 14px;">(三)、<strong>将A的隔离级别设置为repeatable read(可重复读) </strong> </span></p>
<p><span style="font-size: 14px;">&nbsp;在B未更新数据之前： </span></p>
<div class="blog_content" style="text-align: left;"><span style="font-size: 14px;"> <strong>客户端A： </strong> </span></div>
<div class="blog_content" style="text-align: left;"><span style="font-size: 14px;"><img src="./MySQL-事务隔离级别设置 - John_ABC - 博客园_files/0bf52be3-e873-3f3f-8d56-d703a8f678ab.jpg" alt="" width="643" height="319"></span></div>
<p><span style="font-size: 14px;"> B更新数据： </span></p>
<p><span style="font-size: 14px;"><strong>客户端B： </strong> </span></p>
<p><span style="font-size: 14px;"><img src="./MySQL-事务隔离级别设置 - John_ABC - 博客园_files/e58d1814-bdca-3313-bcf5-339e3678536a.jpg" alt="" width="645" height="333"></span></p>
<p><span style="font-size: 14px;"><strong>客户端A： </strong> </span></p>
<p><span style="font-size: 14px;"><img src="./MySQL-事务隔离级别设置 - John_ABC - 博客园_files/83bfe583-2d57-345a-917e-4ee163235b62.jpg" alt="" width="640" height="497"></span></p>
<p><span style="font-size: 14px;">B插入数据： </span></p>
<p><span style="font-size: 14px;"><strong>客户端B： </strong> </span></p>
<p><span style="font-size: 14px;"><img src="./MySQL-事务隔离级别设置 - John_ABC - 博客园_files/192348aa-4fa5-3d5f-a4f9-4660ddd725cd.jpg" alt="" width="641" height="366"></span></p>
<p><span style="font-size: 14px;"><strong>客户端A： </strong> </span></p>
<p><span style="font-size: 14px;"><img src="./MySQL-事务隔离级别设置 - John_ABC - 博客园_files/4398c5b1-434c-3380-ba19-060154cf2070.jpg" alt="" width="641" height="351"></span></p>
<p><span style="font-size: 14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 由以上的实验可以得出结论，可重复读隔离级别只允许读取已提交记录，而且在一个事务两次读取一个记录期间，其他事务部的更新该记录。但该事务不要求与其他 事务可串行化。例如，当一个事务可以找到由一个已提交事务更新的记录，但是可能产生幻读问题(注意是可能，因为数据库对隔离级别的实现有所差别)。像以上 的实验，就没有出现数据幻读的问题。 </span></p>
<p><span style="font-size: 14px;">(<strong>四)、<strong>将A的隔离级别设置为 </strong> 可串行化 (Serializable) </strong> </span></p>
<p><span style="font-size: 14px;"><strong>A端打开事务，B端插入一条记录 </strong> </span></p>
<p><span style="font-size: 14px;"><strong>事务A端： </strong> </span></p>
<p><span style="font-size: 14px;"><img src="./MySQL-事务隔离级别设置 - John_ABC - 博客园_files/c604c5ce-311d-3923-8dcd-36b0188f4f31.jpg" alt="" width="639" height="234"></span></p>
<p><span style="font-size: 14px;"><strong>事务B端： </strong> </span></p>
<p><span style="font-size: 14px;"><img src="./MySQL-事务隔离级别设置 - John_ABC - 博客园_files/c488f9d9-7da2-3e6d-9a82-2b92d1051afd.jpg" alt="" width="640" height="141"></span></p>
<p><span style="font-size: 14px;">因为此时事务A的隔离级别设置为serializable，开始事务后，并没有提交，所以事务B只能等待。 </span></p>
<p><span style="font-size: 14px;"><strong>事务A提交事务： </strong> </span></p>
<p><span style="font-size: 14px;"><strong>事务A端 </strong> </span></p>
<p><span style="font-size: 14px;"><img src="./MySQL-事务隔离级别设置 - John_ABC - 博客园_files/322ed59a-b2b9-338c-a2f0-09c9b7707577.jpg" alt="" width="639" height="73"></span></p>
<p><span style="font-size: 14px;"><strong>事务B端 </strong> </span></p>
<p><span style="font-size: 14px;"><img src="./MySQL-事务隔离级别设置 - John_ABC - 博客园_files/8e60e19b-09af-31a7-b8d3-8e638bbf177c.jpg" alt="" width="644" height="47"></span></p>
<p><span style="font-size: 14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span style="font-size: 14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; serializable完全锁定字段，若一个事务来查询同一份数据就必须等待，直到前一个事务完成并解除锁定为止 。是完整的隔离级别，会锁定对应的数据表格，因而会有效率的问题。 </span></p>
<p>&nbsp;</p>
<p><span style="font-size: 14px;">利用悲观锁</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<table style="width: 80%;" border="1" cellspacing="1" cellpadding="1">
<tbody>
<tr>
<td>时间</td>
<td>取款事务</td>
<td>支票转账事务</td>
</tr>
<tr>
<td>T1</td>
<td>开始事务</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>T2</td>
<td>&nbsp;</td>
<td>开始事务</td>
</tr>
<tr>
<td>T3</td>
<td>select * from ACCOUNTS where ID = 1 for update；<br>
查询账户余额为1000元；这条记录被锁定。</td>
<td>&nbsp;</td>




</tr>
<tr>
<td>T4</td>
<td>&nbsp;</td>
<td>select * from ACCOUNTS where ID = 1 for update；<br>
执行该语句时，事务停下来等待取款事务解除对这条记录的锁定。</td>




</tr>
<tr>
<td>T5</td>
<td>取出100，把存款余额改为900元</td>
<td>&nbsp;</td>




</tr>
<tr>
<td>T6</td>
<td>提交事务</td>
<td>&nbsp;</td>




</tr>
<tr>
<td>T7</td>
<td>&nbsp;</td>
<td>事务恢复运行，查询结果显示存款余额为900.这条记录被锁定。</td>




</tr>
<tr>
<td>T8</td>
<td>&nbsp;</td>
<td>汇入100元，把存款余额改为1000元。</td>




</tr>
<tr>
<td>T9</td>
<td>&nbsp;</td>
<td>提交事务</td>



</tr>



</tbody>


</table>
<p>&nbsp;</p>
<p>用图展示隔离级别及对应缺陷：</p>
<p>　　READ UNCOMMITTED 在该隔离级别下，所有事务都可以看到其它未提交事务的执行结果。如下图所示：&nbsp;<img style="display: block; margin-left: auto; margin-right: auto;" src="./MySQL-事务隔离级别设置 - John_ABC - 博客园_files/544496-20170704114431409-2110049503.png" alt="" width="457" height="340"></p>
<p>　　　　缺陷：事务2查询到的数据是事务1中修改但未提交的数据，但因为事务1回滚了数据，所以事务2查询的数据是不正确的，因此出现了脏读的问题。</p>
<p>　　READ COMMITTED 在该隔离级别下，一个事务从开始到提交之前对数据所做的改变对其它事务是不可见的，这样就解决在READ-UNCOMMITTED级别下的脏读问题。但如果一个事务在执行过程中，其它事务的提交对该事物中的数据发生改变，那么该事务中的一个查询语句在两次执行过程中会返回不一样的结果。如下图所示：&nbsp;</p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="./MySQL-事务隔离级别设置 - John_ABC - 博客园_files/544496-20170704114531659-1048561987.png" alt="" width="610" height="410"></p>
<p><br>　　　　缺陷：事务2执行update语句但未提交前，事务1的前两个select操作返回结果是相同的。但事务2执行commit操作后，事务1的第三个select操作就读取到事务2对数据的改变，导致与前两次select操作返回不同的数据，因此出现了不可重复读的问题。</p>
<p>　　REPEATABLE READ 这是MySQL的默认事务隔离级别，能确保事务在并发读取数据时会看到同样的数据行，解决了READ-COMMITTED隔离级别下的不可重复读问题。mysql的InnoDB存储引擎通过多版本并发控制（Multi_Version Concurrency Control, MVCC）机制来解决该问题。在该机制下，事务每开启一个实例，都会分配一个版本号给它，如果读取的数据行正在被其它事务执行DELETE或UPDATE操作（即该行上有排他锁），这时该事物的读取操作不会等待行上的锁释放，而是根据版本号去读取行的快照数据（记录在undo log中），这样，事务中的查询操作返回的都是同一版本下的数据，解决了不可重复读问题。其原理如下图所示：&nbsp;</p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="./MySQL-事务隔离级别设置 - John_ABC - 博客园_files/544496-20170704114613253-334923445.png" alt="" width="481" height="222"></p>
<p>　　　　缺陷：虽然该隔离级别下解决了不可重复读问题，但理论上会导致另一个问题：幻读（Phantom Read）。正如上面所讲，一个事务在执行过程中，另一个事物对已有数据行的更改，MVCC机制可保障该事物读取到的原有数据行的内容相同，但并不能阻止另一个事务插入新的数据行，这就会导致该事物中凭空多出数据行，像出现了幻读一样，这便是幻读问题。如下图所示： </p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="./MySQL-事务隔离级别设置 - John_ABC - 博客园_files/544496-20170704114631440-910829991.png" alt="" width="656" height="542"></p>
<p>　　　　缺陷：事务2对id=1的行内容进行了修改并且执行了commit操作，事务1中的第二个select操作在MVCC机制的作用下返回的仍是v=1的数据。但事务3执行了insert操作，事务1第三次执行select操作时便返回了id=2的数据行，与前两次的select操作返回的值不一样。需要说明的是，REPEATABLE-READ隔离级别下的幻读问题是SQL标准定义下理论上会导致的问题，MySQL的InnoDB存储引擎在该隔离级别下，采用了Next-Key Locking锁机制避免了幻读问题。Next-Key Locking锁机制将在后面的锁章节中讲到。</p>
<p>　　SERIALIZABLE 这是事务的最高隔离级别，通过强制事务排序，使之不可能相互冲突，就是在每个读的数据行加上共享锁来实现。在该隔离级别下，可以解决前面出现的脏读、不可重复读和幻读问题，但也会导致大量的超时和锁竞争现象，一般不推荐使用。</p>
<p><span style="font-size: 14px;">　　转自:http://xm-king.iteye.com/blog/770721</span></p>
<p><span style="font-size: 14px;">　　参考：http://blog.csdn.net/u013235478/article/details/50625602</span></p>
<p><span style="font-size: 14px;">　　更多测试:</span></p>
<p><span style="font-size: 14px;">　　　　<a href="http://blog.csdn.net/wangsifu2009/article/details/6715120" target="_blank">http://blog.csdn.net/wangsifu2009/article/details/6715120</a></span></p>
<p><span style="font-size: 14px;">　　　　<a href="http://www.2cto.com/database/201412/359238.html" target="_blank">http://www.2cto.com/database/201412/359238.html</a><br></span></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory">分类: <a href="https://www.cnblogs.com/JohnABC/category/518740.html" target="_blank">MySQL</a></div>
<div id="EntryTag"></div>
<div id="blog_post_info"><div id="green_channel">
        <a href="javascript:void(0);" id="green_channel_digg" onclick="DiggIt(3521061,cb_blogId,1);green_channel_success(this,&#39;谢谢推荐！&#39;);">好文要顶</a>
            <a id="green_channel_follow" onclick="follow(&#39;2e044496-99e3-e211-8d02-90b11c0b17d6&#39;);" href="javascript:void(0);">关注我</a>
    <a id="green_channel_favorite" onclick="AddToWz(cb_entryId);return false;" href="javascript:void(0);">收藏该文</a>
    <a id="green_channel_weibo" href="javascript:void(0);" title="分享至新浪微博" onclick="ShareToTsina()"><img src="./MySQL-事务隔离级别设置 - John_ABC - 博客园_files/icon_weibo_24.png" alt=""></a>
    <a id="green_channel_wechat" href="javascript:void(0);" title="分享至微信" onclick="shareOnWechat()"><img src="./MySQL-事务隔离级别设置 - John_ABC - 博客园_files/wechat.png" alt=""></a>
</div>
<div id="author_profile">
    <div id="author_profile_info" class="author_profile_info">
            <a href="http://home.cnblogs.com/u/JohnABC/" target="_blank"><img src="./MySQL-事务隔离级别设置 - John_ABC - 博客园_files/20130704152732.png" class="author_avatar" alt=""></a>
        <div id="author_profile_detail" class="author_profile_info">
            <a href="http://home.cnblogs.com/u/JohnABC/">John_ABC</a><br>
            <a href="http://home.cnblogs.com/u/JohnABC/followees">关注 - 6</a><br>
            <a href="http://home.cnblogs.com/u/JohnABC/followers">粉丝 - 57</a>
        </div>
    </div>
    <div class="clear"></div>
    <div id="author_profile_honor"></div>
    <div id="author_profile_follow">
                <a href="javascript:void(0);" onclick="follow(&#39;2e044496-99e3-e211-8d02-90b11c0b17d6&#39;);return false;">+加关注</a>
    </div>
</div>
<div id="div_digg">
    <div class="diggit" onclick="votePost(3521061,&#39;Digg&#39;)">
        <span class="diggnum" id="digg_count">4</span>
    </div>
    <div class="buryit" onclick="votePost(3521061,&#39;Bury&#39;)">
        <span class="burynum" id="bury_count">0</span>
    </div>
    <div class="clear"></div>
    <div class="diggword" id="digg_tips">
    </div>
</div>
<script type="text/javascript">
    currentDiggType = 0;
</script></div>
<div class="clear"></div>
<div id="post_next_prev"><a href="https://www.cnblogs.com/JohnABC/p/3520981.html" class="p_n_p_prefix">« </a> 上一篇：<a href="https://www.cnblogs.com/JohnABC/p/3520981.html" title="发布于2014-01-15 15:50">PHP-学习大规模高并发Web系统架构及开发推荐书籍</a><br><a href="https://www.cnblogs.com/JohnABC/p/3529786.html" class="p_n_p_prefix">» </a> 下一篇：<a href="https://www.cnblogs.com/JohnABC/p/3529786.html" title="发布于2014-01-22 14:58">PHP-FastCGI详解</a><br></div>
</div>


		</div>
		<p class="postfoot">
			posted on <span id="post-date">2014-01-15 16:25</span> <a href="https://www.cnblogs.com/JohnABC/">John_ABC</a> 阅读(<span id="post_view_count">16681</span>) 评论(<span id="post_comment_count">2</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=3521061" rel="nofollow">编辑</a> <a href="https://www.cnblogs.com/JohnABC/p/3521061.html#" onclick="AddToWz(3521061);return false;">收藏</a>
		</p>
	</div>
	<script type="text/javascript">var allowComments=true,cb_blogId=156331,cb_entryId=3521061,cb_blogApp=currentBlogApp,cb_blogUserGuid='2e044496-99e3-e211-8d02-90b11c0b17d6',cb_entryCreatedDate='2014/1/15 16:25:00';loadViewCount(cb_entryId);var cb_postType=1;var isMarkdown=false;</script>
	
	</div><a name="!comments"></a><div id="blog-comments-placeholder"><div id="comments_pager_top"></div>
<a name="评论"></a>
<div id="comments">
<h3>评论</h3>
	
	
			<div class="post">
				<h2>
					<a href="https://www.cnblogs.com/JohnABC/p/3521061.html#3739354" class="layer">#1楼</a><a name="3739354" id="comment_anchor_3739354"></a>
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</h2>
				<div id="comment_body_3739354" class="blog_comment_body">厉害，好详细👍</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3739354,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3739354,&#39;Bury&#39;,this)">反对(0)</a></div><span id="comment_3739354_avatar" style="display:none;">http://pic.cnblogs.com/face/1084423/20170723210649.png</span>
				<div class="postfoot">
					 <span class="comment_date">2017-07-19 23:55</span> | <a id="a_comment_author_3739354" href="https://www.cnblogs.com/uptowncat/" target="_blank">UpTownCat</a> <a href="http://msg.cnblogs.com/send/UpTownCat" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
				</div>
			</div>
		
			<div class="post">
				<h2>
					<a href="https://www.cnblogs.com/JohnABC/p/3521061.html#3960775" class="layer">#2楼</a><a name="3960775" id="comment_anchor_3960775"></a><span id="comment-maxId" style="display:none;">3960775</span><span id="comment-maxDate" style="display:none;">2018/4/25 14:41:04</span>
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</h2>
				<div id="comment_body_3960775" class="blog_comment_body">在最后一张图中的事务2里做的修改是无效的吗？</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3960775,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3960775,&#39;Bury&#39;,this)">反对(0)</a></div>
				<div class="postfoot">
					 <span class="comment_date">2018-04-25 14:41</span> | <a id="a_comment_author_3960775" href="https://www.cnblogs.com/a14907/" target="_blank">a14907</a> <a href="http://msg.cnblogs.com/send/a14907" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
				</div>
			</div>
		
</div>
<div id="comments_pager_bottom"></div></div><script type="text/javascript">var commentManager = new blogCommentManager();commentManager.renderComments(0);</script>
<div id="comment_form" class="commentform">
<a name="commentform"></a>
<div id="divCommentShow"></div>
<div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="https://www.cnblogs.com/JohnABC/p/3521061.html#" onclick="return RefreshPage();">刷新页面</a><a href="https://www.cnblogs.com/JohnABC/p/3521061.html#top">返回顶部</a></div>
<div id="comment_form_container"><div class="login_tips">注册用户登录后才能发表评论，请 <a rel="nofollow" href="javascript:void(0);" class="underline" onclick="return login(&#39;commentform&#39;);">登录</a> 或 <a rel="nofollow" href="javascript:void(0);" class="underline" onclick="return register();">注册</a>，<a href="http://www.cnblogs.com/">访问</a>网站首页。</div></div>
<div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
<div id="ad_t2"><a href="http://www.ucancode.com/index.htm" target="_blank" onclick="ga(&#39;send&#39;, &#39;event&#39;, &#39;Link&#39;, &#39;click&#39;, &#39;T2-工控&#39;)">【推荐】超50万C++/C#源码: 大型实时仿真HMI组态CAD\GIS图形源码！</a><br><a href="https://gitee.com/enterprises?from=bky-2" target="_blank" onclick="ga(&#39;send&#39;, &#39;event&#39;, &#39;Link&#39;, &#39;click&#39;, &#39;T2-gitee&#39;)">【推荐】专业便捷的企业级代码托管服务 - Gitee 码云</a><br></div>
<div id="opt_under_post"></div>
<script async="async" src="./MySQL-事务隔离级别设置 - John_ABC - 博客园_files/gpt.js.下载"></script>
<script>
  var googletag = googletag || {};
  googletag.cmd = googletag.cmd || [];
</script>
<script>
  googletag.cmd.push(function() {
        googletag.defineSlot('/1090369/C1', [300, 250], 'div-gpt-ad-1546353474406-0').addService(googletag.pubads());
        googletag.defineSlot('/1090369/C2', [468, 60], 'div-gpt-ad-1539008685004-0').addService(googletag.pubads());
        googletag.pubads().enableSingleRequest();
        googletag.enableServices();
  });
</script>
<div id="cnblogs_c1" class="c_ad_block">
    <div id="div-gpt-ad-1546353474406-0" style="height:250px; width:300px;" data-google-query-id="CMDBqP2k1uACFQ4xlgodlfcB_A"><div id="google_ads_iframe_/1090369/C1_0__container__" style="border: 0pt none;"><iframe id="google_ads_iframe_/1090369/C1_0" title="3rd party ad content" name="google_ads_iframe_/1090369/C1_0" width="300" height="250" scrolling="no" marginwidth="0" marginheight="0" frameborder="0" style="border: 0px; vertical-align: bottom;" data-google-container-id="1" data-load-complete="true" src="./MySQL-事务隔离级别设置 - John_ABC - 博客园_files/saved_resource.html"></iframe></div></div>
</div>
<div id="under_post_news"><div class="itnews c_ad_block"><b>相关博文：</b><br>·  <a href="https://www.cnblogs.com/JohnABC/p/3521061.html" target="_blank" onclick="clickRecomItmem(undefined,&#39;undefined&#39;)">MySQL-事务隔离级别设置</a><br>·  <a href="https://www.cnblogs.com/Jacck/p/4589721.html" target="_blank" onclick="clickRecomItmem(undefined,&#39;undefined&#39;)">mysql事务隔离级别设置</a><br>·  <a href="https://www.cnblogs.com/protected/p/6526857.html" target="_blank" onclick="clickRecomItmem(undefined,&#39;undefined&#39;)">MySQL事务隔离级别详解</a><br>·  <a href="https://www.cnblogs.com/23lalala/p/5587484.html" target="_blank" onclick="clickRecomItmem(undefined,&#39;undefined&#39;)">mysql事务隔离级别</a><br>·  <a href="https://www.cnblogs.com/renolei/p/5225488.html" target="_blank" onclick="clickRecomItmem(undefined,&#39;undefined&#39;)">[MySQL] 事务隔离级别</a><br></div></div>
<div id="cnblogs_c2" class="c_ad_block">
    <div id="div-gpt-ad-1539008685004-0" style="height:60px; width:468px;" data-google-query-id="CIfDqP2k1uACFYc7lgodDz8FrQ"><div id="google_ads_iframe_/1090369/C2_0__container__" style="border: 0pt none;"><iframe id="google_ads_iframe_/1090369/C2_0" title="3rd party ad content" name="google_ads_iframe_/1090369/C2_0" width="468" height="60" scrolling="no" marginwidth="0" marginheight="0" frameborder="0" style="border: 0px; vertical-align: bottom;" data-google-container-id="2" data-load-complete="true" src="./MySQL-事务隔离级别设置 - John_ABC - 博客园_files/saved_resource(1).html"></iframe></div></div>
</div>
<div id="under_post_kb"><div class="itnews c_ad_block"><b>最新新闻</b>：<br> ·  <a href="https://news.cnblogs.com/n/620275/" target="_blank">小米的互联网商业化之路：左手To C，右手To B</a><br> ·  <a href="https://news.cnblogs.com/n/620274/" target="_blank">变身吸引程序员和科技公司磁石 揭示纽约演变为科技城市秘诀</a><br> ·  <a href="https://news.cnblogs.com/n/620273/" target="_blank">蔚来李斌接受美国知名访谈节目专访：买蔚来就是在买新的生活方式</a><br> ·  <a href="https://news.cnblogs.com/n/620272/" target="_blank">程维卸任快的打车法人及总经理 王庆山接任</a><br> ·  <a href="https://news.cnblogs.com/n/620271/" target="_blank">2019重点在哪？ 风口、赛道与硬核投资时代</a><br>» <a href="http://news.cnblogs.com/" title="IT新闻" target="_blank">更多新闻...</a></div></div>
<div id="HistoryToday" class="c_ad_block"></div>
<script type="text/javascript">
 if(enablePostBottom()) {
    codeHighlight();
    fixPostBody();
    setTimeout(function () { incrementViewCount(cb_entryId); }, 50);
    deliverT2();
    deliverC1();
    deliverC2();    
    loadNewsAndKb();
    loadBlogSignature();
    LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
    GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
    loadOptUnderPost();
    GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);  
}
</script>
</div>

    
</div>
</div>
<div id="leftmenu">


<h3>导航</h3>
<ul>
<li>
<a id="blog_nav_sitehome" href="https://www.cnblogs.com/">博客园</a></li>
<li>
<a id="blog_nav_myhome" class="two_words" href="https://www.cnblogs.com/JohnABC/">首页</a></li>
<li>
<a id="blog_nav_newpost" rel="nofollow" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">新随笔</a></li>
<li>
<a id="blog_nav_contact" accesskey="9" class="two_words" rel="nofollow" href="https://msg.cnblogs.com/send/John_ABC">联系</a></li>
<li>
<a id="blog_nav_rss" class="two_words" href="https://www.cnblogs.com/JohnABC/rss">订阅</a>
<a id="blog_nav_rss_image" href="https://www.cnblogs.com/JohnABC/rss"><img src="./MySQL-事务隔离级别设置 - John_ABC - 博客园_files/xml.gif" alt="订阅"></a>
</li>
<li>
<a id="blog_nav_admin" class="two_words" rel="nofollow" href="https://i.cnblogs.com/">管理</a></li>
</ul>

<div id="blog-calendar" style=""><table id="blogCalendar" class="Cal" cellspacing="0" cellpadding="0" title="Calendar">
	<tbody><tr><td colspan="7"><table class="CalTitle" cellspacing="0">
		<tbody><tr><td class="CalNextPrev"><a href="javascript:void(0);" onclick="loadBlogCalendar(&#39;2019/01/01&#39;);return false;">&lt;</a></td><td align="center">2019年2月</td><td class="CalNextPrev" align="right"><a href="javascript:void(0);" onclick="loadBlogCalendar(&#39;2019/03/01&#39;);return false;">&gt;</a></td></tr>
	</tbody></table></td></tr><tr><th class="CalDayHeader" align="center" abbr="日" scope="col">日</th><th class="CalDayHeader" align="center" abbr="一" scope="col">一</th><th class="CalDayHeader" align="center" abbr="二" scope="col">二</th><th class="CalDayHeader" align="center" abbr="三" scope="col">三</th><th class="CalDayHeader" align="center" abbr="四" scope="col">四</th><th class="CalDayHeader" align="center" abbr="五" scope="col">五</th><th class="CalDayHeader" align="center" abbr="六" scope="col">六</th></tr><tr><td class="CalOtherMonthDay" align="center">27</td><td class="CalOtherMonthDay" align="center">28</td><td class="CalOtherMonthDay" align="center">29</td><td class="CalOtherMonthDay" align="center">30</td><td class="CalOtherMonthDay" align="center">31</td><td align="center">1</td><td class="CalWeekendDay" align="center">2</td></tr><tr><td class="CalWeekendDay" align="center">3</td><td align="center">4</td><td align="center">5</td><td align="center">6</td><td align="center">7</td><td align="center">8</td><td class="CalWeekendDay" align="center">9</td></tr><tr><td class="CalWeekendDay" align="center">10</td><td align="center">11</td><td align="center">12</td><td align="center">13</td><td align="center">14</td><td align="center">15</td><td class="CalWeekendDay" align="center">16</td></tr><tr><td class="CalWeekendDay" align="center">17</td><td align="center">18</td><td align="center">19</td><td align="center">20</td><td align="center">21</td><td align="center">22</td><td class="CalWeekendDay" align="center">23</td></tr><tr><td class="CalWeekendDay" align="center">24</td><td class="CalTodayDay" align="center">25</td><td align="center">26</td><td align="center">27</td><td align="center">28</td><td class="CalOtherMonthDay" align="center">1</td><td class="CalOtherMonthDay" align="center">2</td></tr><tr><td class="CalOtherMonthDay" align="center">3</td><td class="CalOtherMonthDay" align="center">4</td><td class="CalOtherMonthDay" align="center">5</td><td class="CalOtherMonthDay" align="center">6</td><td class="CalOtherMonthDay" align="center">7</td><td class="CalOtherMonthDay" align="center">8</td><td class="CalOtherMonthDay" align="center">9</td></tr>
</tbody></table></div><script type="text/javascript">loadBlogDefaultCalendar();</script>
<meta name="vs_showGrid" content="False">

<h3>公告</h3>
<div id="blog-news"><div align="center"><a href="https://www.amazingcounters.com/"><img border="0" src="./MySQL-事务隔离级别设置 - John_ABC - 博客园_files/counter.php" alt="AmazingCounters.com"></a></div><div id="profile_block">昵称：<a href="https://home.cnblogs.com/u/JohnABC/">John_ABC</a><br>园龄：<a href="https://home.cnblogs.com/u/JohnABC/" title="入园时间：2013-07-03">5年7个月</a><br>粉丝：<a href="https://home.cnblogs.com/u/JohnABC/followers/">57</a><br>关注：<a href="https://home.cnblogs.com/u/JohnABC/followees/">6</a><div id="p_b_follow"><a href="javascript:void(0);" onclick="follow(&#39;2e044496-99e3-e211-8d02-90b11c0b17d6&#39;)">+加关注</a></div><script>getFollowStatus('2e044496-99e3-e211-8d02-90b11c0b17d6')</script></div></div><script type="text/javascript">loadBlogNews();</script>

<div id="blog-sidecolumn"></div><script type="text/javascript">loadBlogSideColumn();</script>

</div>
</div>
<div class="clear"></div>
<div id="footer">

<p id="footer">
	Powered by: 
	<br>
	
	<a id="Footer1_Hyperlink3" name="Hyperlink1" href="https://www.cnblogs.com/" style="font-family:Verdana;font-size:12px;">博客园</a>
	<br>
	Copyright © John_ABC
</p>
</div>
</div>




<iframe id="google_osd_static_frame_4766571725398" name="google_osd_static_frame" style="display: none; width: 0px; height: 0px;" src="./MySQL-事务隔离级别设置 - John_ABC - 博客园_files/saved_resource(2).html"></iframe></body></html>