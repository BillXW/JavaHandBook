<!DOCTYPE html>
<!-- saved from url=(0046)https://www.cnblogs.com/lsgxeva/p/7800564.html -->
<html lang="zh-cn"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="referrer" content="origin">
    <title>算法设计之五大常用算法设计方法总结 - lsgxeva - 博客园</title>
<meta property="og:description" content="算法设计之五大常用算法设计方法总结 来源 http://blog.csdn.net/zolalad/article/details/11393915">
    <link type="text/css" rel="stylesheet" href="./算法设计之五大常用算法设计方法总结 - lsgxeva - 博客园_files/blog-common.css">
<link id="MainCss" type="text/css" rel="stylesheet" href="./算法设计之五大常用算法设计方法总结 - lsgxeva - 博客园_files/bundle-SimpleMemory.css">
<link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="./算法设计之五大常用算法设计方法总结 - lsgxeva - 博客园_files/bundle-SimpleMemory-mobile.css">
    <link title="RSS" type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/lsgxeva/rss">
    <link title="RSD" type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/lsgxeva/rsd.xml">
<link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/lsgxeva/wlwmanifest.xml">
    <script src="./算法设计之五大常用算法设计方法总结 - lsgxeva - 博客园_files/osd.js"></script><script src="./算法设计之五大常用算法设计方法总结 - lsgxeva - 博客园_files/amp4ads-host-v0.js"></script><script src="./算法设计之五大常用算法设计方法总结 - lsgxeva - 博客园_files/pubads_impl_rendering_2019021401.js"></script><script async="" src="./算法设计之五大常用算法设计方法总结 - lsgxeva - 博客园_files/analytics.js"></script><script src="./算法设计之五大常用算法设计方法总结 - lsgxeva - 博客园_files/jquery-2.2.0.min.js"></script>
    <script>var currentBlogId=250005;var currentBlogApp='lsgxeva',cb_enable_mathjax=false;var isLogined=false;</script>
    <script src="./算法设计之五大常用算法设计方法总结 - lsgxeva - 博客园_files/blog-common.js" type="text/javascript"></script>
<link rel="preload" href="./算法设计之五大常用算法设计方法总结 - lsgxeva - 博客园_files/integrator.js" as="script"><script type="text/javascript" src="./算法设计之五大常用算法设计方法总结 - lsgxeva - 博客园_files/integrator.js"></script><script src="./算法设计之五大常用算法设计方法总结 - lsgxeva - 博客园_files/pubads_impl_2019021401.js" async=""></script></head>
<body>
<a name="top"></a>


<!--done-->
<div id="home">
<div id="header">
	<div id="blogTitle">
	<a id="lnkBlogLogo" href="https://www.cnblogs.com/lsgxeva/"><img id="blogLogo" src="./算法设计之五大常用算法设计方法总结 - lsgxeva - 博客园_files/logo.gif" alt="返回主页"></a>			
		
<!--done-->
<h1><a id="Header1_HeaderTitle" class="headermaintitle" href="https://www.cnblogs.com/lsgxeva/">云水</a></h1>
<h2>MyGitee - https://gitee.com/lsgx/ <br>
MyGithub - https://github.com/lsgxeva/ <br></h2>



		
	</div><!--end: blogTitle 博客的标题和副标题 -->
	<div id="navigator">
		
<ul id="navList">
<li><a id="blog_nav_sitehome" class="menu" href="https://www.cnblogs.com/">博客园</a></li>
<li><a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/lsgxeva/">首页</a></li>
<li><a id="blog_nav_newpost" class="menu" rel="nofollow" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">新随笔</a></li>
<li><a id="blog_nav_contact" class="menu" rel="nofollow" href="https://msg.cnblogs.com/send/lsgxeva">联系</a></li>
<li><a id="blog_nav_rss" class="menu" href="https://www.cnblogs.com/lsgxeva/rss">订阅</a>
<!--<a id="blog_nav_rss_image" class="aHeaderXML" href="https://www.cnblogs.com/lsgxeva/rss"><img src="//www.cnblogs.com/images/xml.gif" alt="订阅" /></a>--></li>
<li><a id="blog_nav_admin" class="menu" rel="nofollow" href="https://i.cnblogs.com/">管理</a></li>
</ul>
		<div class="blogStats">
			
			<div id="blog_stats">
<span id="stats_post_count">随笔 - 734&nbsp; </span>
<span id="stats_article_count">文章 - 0&nbsp; </span>
<span id="stats-comment_count">评论 - 10</span>
</div>
			
		</div><!--end: blogStats -->
	</div><!--end: navigator 博客导航栏 -->
</div><!--end: header 头部 -->

<div id="main">
	<div id="mainContent">
	<div class="forFlow">
		
        <div id="post_detail">
<!--done-->
<div id="topics">
	<div class="post">
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/lsgxeva/p/7800564.html">算法设计之五大常用算法设计方法总结</a>
		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body"><h1>算法设计之五大常用算法设计方法总结</h1>
<p>&nbsp;</p>
<p>来源 http://blog.csdn.net/zolalad/article/details/11393915</p>
<p>&nbsp;</p>
<pre><strong>一、【分治法】</strong></pre>
<pre>&nbsp;在计算机科学中，分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。<strong>这个技巧是很多高效算法的基础</strong>，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……等。任何一个可以用计算机求解的问题所需的计算时间都与其规模有关。问题的规模越小，越容易直接求解，解题所需的计算时间也越少。例如，对于n个元素的排序问题，当n=1时，不需任何计算。n=2时，只要作一次比较即可排好序。n=3时只要作3次比较即可，…。而当n较大时，问题就不那么容易处理了。要想直接解决一个规模较大的问题，有时是相当困难的。</pre>
<pre>分治法的设计思想是，将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便<strong>各个击破，分而治之</strong>。</pre>
<pre>分治策略是：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些<strong>子问题互相独立且与原问题形式相同</strong>，递归地解这些子问题，然后<strong>将各子问题的解合并得到原问题的解</strong>。这种算法设计策略叫做<strong>分治法</strong>。</pre>
<pre>如果原问题可分割成k(1&lt;k≤n)个子问题， 且这些子问题都可解并可利用这些子问题的解求出原问题的解，那么这种分治法就是可行的。由分治法产生的子问题往往是原问题的较小模式，<strong>这就为使用"递归技术"提供了方便</strong>。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解，这自然导致递归过程的产生。"<strong>分治"与"递归"</strong><strong>像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法</strong>。</pre>
<pre><strong>分治法所能解决的问题一般具有以下几个特征：</strong></pre>
<pre>1) 该问题的规模缩小到一定的程度就可以容易地解决</pre>
<pre>2) 该问题可以分解为若干个规模较小的相同问题，即该问题具有<strong>最优子结构</strong>性质。（前提）</pre>
<pre>3) 利用该问题分解出的子问题的解可以<strong>合并</strong>为该问题的解；（最关键的一点）</pre>
<pre>4) 该问题所分解出的各个子问题是<strong>相互独立</strong>的，即子问题之间<strong>不包含公共的子子问题</strong>。</pre>
<pre>上述的第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；<strong>第二条特征是应用分治法的前提</strong>它也是大多数问题可以满足的，此特征反映了<strong>递归</strong>思想的应用；第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。<strong>第四条特征涉及到分治法的效率</strong>，<strong>如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。</strong></pre>
<pre><strong>分治法的基本步骤</strong></pre>
<pre>分治法在<strong>每一层递归上</strong>都有三个步骤：</pre>
<pre>1)分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；</pre>
<pre>2)解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题</pre>
<pre>3)合并：将各个子问题的解合并为原问题的解。</pre>
<pre><strong>它的一般的算法设计模式如下：</strong></pre>
<pre>Divide-and-Conquer(P)</pre>
<pre>if |P|≤n0 {</pre>
<pre>&nbsp;&nbsp;     then return(ADHOC(P))</pre>
<pre>}else{</pre>
<pre>         将P继续分解为较小的子问题 P1 ,P2 ,...,Pk</pre>
<pre>     for i←1 to k</pre>
<pre>&nbsp;&nbsp;&nbsp;  do yi ← Divide-and-Conquer(Pi) △ 递归解决Pi</pre>
<pre>     T ← MERGE(y1,y2,...,yk) △ 合并子问题</pre>
<pre>}</pre>
<pre>return(T)</pre>
<pre>其中|P|表示问题P的规模；n0为一阈值，表示当问题P的规模不超过n0时，问题已容易直接解出，不必再继续分解。ADHOC(P)是该分治法中的基本子算法，用于直接解小规模的问题P。因此，当P的规模不超过n0时直接用算法ADHOC(P)求解。算法MERGE(y1,y2,...,yk)是该分治法中的合并子算法，用于将P的子问题P1 ,P2 ,...,Pk的相应的解y1,y2,...,yk合并为P的解。</pre>
<pre><strong>分治法的应用：1.递归与HANOI塔问题； 2.二分法求方程近似解 &nbsp;&nbsp;&nbsp;3. 用C++实现合并排序 &nbsp;&nbsp;4.求最大值和最小值的分治算法</strong></pre>
<pre><strong>分治法的复杂性分析</strong></pre>
<pre>一个分治法将规模为n的问题分成k个规模为n／m的子问题去解。设分解阀值n0=1，且adhoc解规模为1的问题耗费1个单位时间。再设将原问题分解为k个子问题以及用merge将k个子问题的解合并为原问题的解需用f(n)个单位时间。用T(n)表示该分治法解规模为|P|=n的问题所需的计算时间，则有： </pre>
<p><img src="./算法设计之五大常用算法设计方法总结 - lsgxeva - 博客园_files/20130908192032234" alt=""></p>
<pre>通过迭代法求得方程的解： </pre>
<p><img src="./算法设计之五大常用算法设计方法总结 - lsgxeva - 博客园_files/20130908191944265" alt=""></p>
<pre>递归方程及其解只给出n等于m的方幂时T(n)的值，但是如果认为T(n)足够平滑，那么由n等于m的方幂时T(n)的值可以估计T(n)的增长速度。通常假定T(n)是单调上升的，从而当mi≤n&lt;mi+1时，T(mi)≤T(n)&lt;T(mi+1)。</pre>
<pre><strong>二、【动态规划法】</strong></pre>
<pre><strong>最优化原理</strong></pre>
<pre>1951年美国数学家R．Bellman等人，根据一类<strong>多阶段问题</strong>的特点，把“<strong>多阶段决策</strong>”问题变换为<strong>一系列</strong>互相联系的“<strong>单阶段问题</strong>”，然后<strong>逐个加以解决</strong>。而且<strong>一些静态模型，只要人为地引进“时间”因素，分成时段，就可以转化成多阶段的动态模型，用动态规划方法去处理</strong>。与此同时，他提出了解决这类问题的“<strong>最优化原理</strong>”(Principle of optimality)：“一个过程的最优决策具有这样的性质：即无论其初始状态和初始决策如何，其今后诸策略对以第一个决策所形成的状态作为初始状态的过程而言，必须构成最优策略”。简言之，一个最优策略的子策略，对于它的初态和终态而言也必是最优的。<strong>这个“最优化原理”如果用数学化一点的语言来描述</strong>的话，就是：假设为了解决某一优化问题，需要依次作出n个决策D1，D2，…，Dn，如若这个决策序列是最优的，对于任何一个整数k，1 &lt; k &lt; n，不论前面k个决策是怎样的，以后的最优决策只取决于由前面决策所确定的当前状态，即以后的决策Dk+1，Dk+2，…，Dn也是最优的。</pre>
<pre><strong>最优化原理是动态规划的基础</strong>，任何一个问题，如果失去了这个最优化原理的支持，就不可能用动态规划方法计算。能采用动态规划求解的<strong>问题都需要满足一定的条件：</strong></pre>
<pre>(1) 问题中的状态必须满足最优化原理；</pre>
<pre>(2) 问题中的状态必须满足无后效性。</pre>
<pre>所谓的无后效性是指：“下一时刻的状态只与当前状态有关，而和当前状态之前的状态无关，当前的状态是对以往决策的总结”。</pre>
<pre><strong>问题求解模式</strong></pre>
<pre>动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤。</pre>
<pre>初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态</pre>
<pre>图1 动态规划决策过程示意图</pre>
<pre><strong>(1)划分阶段：</strong>按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。</pre>
<pre><strong>(2)确定状态和状态变量：</strong>将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。</pre>
<pre><strong>(3)确定决策并写出状态转移方程：</strong>因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两段各状态之间的关系来确定决策。</pre>
<pre><strong>(4)寻找边界条件：</strong>给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。</pre>
<pre><strong>动态规划法的应用：1.动态规划求0/1背包问题 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.最长公共子串问题的实现 </strong>3. 用动态规划实现导弹拦截&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;4.最大化投资回报问题的实现</pre>
<pre><strong>算法实现</strong></pre>
<pre>动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。<strong>使用动态规划求解问题，最重要的就是确定动态规划三要素：问题的阶段,每个阶段的状态以及从前一个阶段转化到后一个阶段之间的递推关系</strong>。递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。确定了动态规划的这三要素，整个求解过程就可以用一<strong>个最优决策表</strong>来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。下面分别以求解最大化投资回报问题和最长公共子序列问题为例阐述用动态规划算法求解问题的一般思路。</pre>
<pre><strong>三、【贪心算法】</strong></pre>
<pre>所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。心算法不是对所有问题都能得到整体最优解，但对范围相当广泛的许多问题他能产生整体最优解或者是整体最优解的近似解。</pre>
<pre><strong>贪心算法的基本思路如下：</strong></pre>
<pre>1.建立数学模型来描述问题。</pre>
<pre>2.把求解的问题分成若干个子问题。</pre>
<pre>3.对每一子问题求解，得到子问题的局部最优解。</pre>
<pre>4.把子问题的解局部最优解合成原来解问题的一个解。</pre>
<pre><strong>实现该算法的过程：</strong></pre>
<pre>从问题的某一初始解出发；</pre>
<pre>while 能朝给定总目标前进一步 do</pre>
<pre>求出可行解的一个解元素；</pre>
<pre>由所有解元素组合成问题的一个可行解；</pre>
<pre><strong>下面是一个可以使用贪心算法解的题目，贪心解的确不错，可惜不是最优解：</strong></pre>
<pre><strong>例题分析：</strong></pre>
<pre>[背包问题]有一个背包，背包容量是M=150。有7个物品，物品可以分割成任意大小。</pre>
<pre>要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。</pre>
<pre>物品： &nbsp;A &nbsp;&nbsp;B &nbsp;&nbsp;C &nbsp;&nbsp;D &nbsp;&nbsp;E &nbsp;&nbsp;&nbsp;F &nbsp;&nbsp;G</pre>
<pre>重量： 35 &nbsp;30 &nbsp;60 &nbsp;50 &nbsp;40 &nbsp;10 &nbsp;25</pre>
<pre>价值： 10 &nbsp;40 &nbsp;30 &nbsp;50 &nbsp;35 &nbsp;40 &nbsp;30</pre>
<pre><strong>分析：</strong></pre>
<pre>目标函数： ∑pi最大</pre>
<pre>约束条件是装入的物品总重量不超过背包容量：∑wi&lt;=M( M=150)</pre>
<pre>（1）根据贪心的策略，每次挑选价值最大的物品装入背包，得到的结果是否最优？</pre>
<pre>（2）每次挑选所占重量最小的物品装入是否能得到最优解？</pre>
<pre>（3）每次选取单位重量价值最大的物品，成为解本题的策略。</pre>
<pre>值得注意的是，贪心算法并不是完全不可以使用，<strong>贪心策略一旦经过证明成立后</strong>，它就是一种高效的算法。贪心算法还是很常见的算法之一，这是由于它简单易行，构造贪心策略不是很困难。可惜的是，它需要证明后才能真正运用到题目的算法中。</pre>
<pre><strong>一般来说，贪心算法的证明围绕着：整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的。</strong></pre>
<pre>对于例题中的3种贪心策略，都是无法成立（无法被证明）的，解释如下：</pre>
<pre>&nbsp;&nbsp;&nbsp; （1）贪心策略：选取价值最大者。反例：</pre>
<pre>&nbsp;&nbsp;&nbsp; W=30</pre>
<pre>&nbsp;&nbsp;&nbsp; 物品：A B C</pre>
<pre>&nbsp;&nbsp;&nbsp; 重量：28 12 12</pre>
<pre>&nbsp;&nbsp;&nbsp; 价值：30 20 20</pre>
<pre>&nbsp;&nbsp;&nbsp; 根据策略，首先选取物品A，接下来就无法再选取了，可是，选取B、C则更好。</pre>
<pre>&nbsp;&nbsp;&nbsp; （2）贪心策略：选取重量最小。它的反例与第一种策略的反例差不多。</pre>
<pre>&nbsp;&nbsp;&nbsp; （3）贪心策略：选取单位重量价值最大的物品。反例：</pre>
<pre>&nbsp;&nbsp;&nbsp; W=30</pre>
<pre>&nbsp;&nbsp;&nbsp; 物品：A B C</pre>
<pre>&nbsp;&nbsp;&nbsp; 重量：28 20 10</pre>
<pre>&nbsp;&nbsp;&nbsp; 价值：28 20 10</pre>
<pre>根据策略，三种物品单位重量价值一样，程序无法依据现有策略作出判断，如果选择A，则答案错误。</pre>
<pre><strong>贪心算法应用：</strong>1.最小生成树之Prim算法 &nbsp;2. 最小生成树之kruskal算法</pre>
<pre>3. 贪心算法在背包中的应用 4.汽车加油问题之贪心算法</pre>
<pre><strong>四、【回溯法】</strong></pre>
<pre>回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</pre>
<pre><strong>1、回溯法的一般描述</strong></pre>
<pre>可用回溯法求解的问题P，通常要能表达为：对于已知的由n元组（x1，x2，…，xn）组成的一个状态空间E={（x1，x2，…，xn）∣xi∈Si ，i=1，2，…，n}，给定关于n元组中的一个分量的一个约束集D，要求E中满足D的全部约束条件的所有n元组。其中Si是分量xi的定义域，且 |Si| 有限，i=1，2，…，n。我们称E中满足D的全部约束条件的任一n元组为问题P的一个解。</pre>
<pre>解问题P的最朴素的方法就是枚举法，即对E中的所有n元组逐一地检测其是否满足D的全部约束，若满足，则为问题P的一个解。但显然，其计算量是相当大的。</pre>
<pre>我们发现，对于许多问题，所给定的约束集D具有完备性，即i元组（x1，x2，…，xi）满足D中仅涉及到x1，x2，…，xi的所有约束意味着j（j&lt;i）元组（x1，x2，…，xj）一定也满足D中仅涉及到x1，x2，…，xj的所有约束，i=1，2，…，n。换句话说，只要存在0≤j≤n-1，使得（x1，x2，…，xj）违反D中仅涉及到x1，x2，…，xj的约束之一，则以（x1，x2，…，xj）为前缀的任何n元组（x1，x2，…，xj，xj+1，…，xn）一定也违反D中仅涉及到x1，x2，…，xi的一个约束，n≥i&gt;j。因此，对于约束集D具有完备性的问题P，一旦检测断定某个j元组（x1，x2，…，xj）违反D中仅涉及x1，x2，…，xj的一个约束，就可以肯定，以（x1，x2，…，xj）为前缀的任何n元组（x1，x2，…，xj，xj+1，…，xn）都不会是问题P的解，因而就不必去搜索它们、检测它们。回溯法正是针对这类问题，利用这类问题的上述性质而提出来的比枚举法效率更高的算法。</pre>
<pre>回溯法首先将问题P的n元组的状态空间E表示成一棵高为n的带权有序树T，把在E中求问题P的所有解转化为在T中搜索问题P的所有解。树T类似于检索树，它可以这样构造：设Si中的元素可排成xi(1) ，xi(2) ，…，xi(mi-1) ，|Si| =mi，i=1，2，…，n。从根开始，让T的第I层的每一个结点都有mi个儿子。这mi个儿子到它们的双亲的边，按从左到右的次序，分别带权xi+1(1) ，xi+1(2) ，…，xi+1(mi) ，i=0，1，2，…，n-1。照这种构造方式，E中的一个n元组（x1，x2，…，xn）对应于T中的一个叶子结点，T的根到这个叶子结点的路径上依次的n条边的权分别为x1，x2，…，xn，反之亦然。另外，对于任意的0≤i≤n-1，E中n元组（x1，x2，…，xn）的一个前缀I元组（x1，x2，…，xi）对应于T中的一个非叶子结点，T的根到这个非叶子结点的路径上依次的I条边的权分别为x1，x2，…，xi，反之亦然。特别，E中的任意一个n元组的空前缀（），对应于T的根。</pre>
<pre>因而，在E中寻找问题P的一个解等价于在T中搜索一个叶子结点，要求从T的根到该叶子结点的路径上依次的n条边相应带的n个权x1，x2，…，xn满足约束集D的全部约束。在T中搜索所要求的叶子结点，很自然的一种方式是从根出发，按深度优先的策略逐步深入，即依次搜索满足约束条件的前缀1元组（x1i）、前缀2元组（x1，x2）、…，前缀I元组（x1，x2，…，xi），…，直到i=n为止。</pre>
<pre>在回溯法中，上述引入的树被称为问题P的状态空间树；树T上任意一个结点被称为问题P的状态结点；树T上的任意一个叶子结点被称为问题P的一个解状态结点；树T上满足约束集D的全部约束的任意一个叶子结点被称为问题P的一个回答状态结点，它对应于问题P的一个解.</pre>
<pre><strong>用回溯法解题的一般步骤：</strong></pre>
<pre>（1）针对所给问题，定义问题的解空间；</pre>
<pre>（2）确定易于搜索的解空间结构；</pre>
<pre>（3）以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。</pre>
<pre>回溯法应用：1.回溯法之数的划分 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.回溯法求解 运动员最佳配对问题 </pre>
<pre>3.回溯法解决汽车加油次数最少问题 4. 用回溯法找出n个自然数中取r个数的全排列</pre>
<pre><strong>五、【分支限界法】</strong></pre>
<pre><strong>基本思想 ：</strong>分支限界法常以广度优先或以最小耗费（最大效益）优先的方式搜索问题的解空间树。 </pre>
<pre>在分支限界法中，每一个活结点只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生其所有儿子结点。在这些儿子结点中，导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被加入活结点表中。 此后，从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。这个过程一直持续到找到所需的解或活结点表为空时为止。</pre>
<pre><strong>常见的两种分支限界法：</strong></pre>
<pre>（1）队列式(FIFO)分支限界法</pre>
<pre>按照队列先进先出（FIFO）原则选取下一个节点为扩展节点。 </pre>
<pre>（2）优先队列式分支限界法</pre>
<pre>按照优先队列中规定的优先级选取优先级最高的节点成为当前扩展节点。</pre>
<pre><strong>分支限界法与回溯法的不同:</strong></pre>
<pre>（1）求解目标：回溯法的求解目标是找出解空间树中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出在某种意义下的最优解。 </pre>
<pre>（2）搜索方式的不同：回溯法以深度优先的方式搜索解空间树，而分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树。</pre>
<pre><strong>解空间树的动态搜索</strong></pre>
<pre>（1）回溯求解0/1背包问题，虽剪枝减少了搜索空间，但整个搜索按深度优先机械进行，是盲目搜索（不可预测本结点以下的结点进行的如何）。</pre>
<pre>（2）回溯求解TSP也是盲目的（虽有目标函数，也只有找到一个可行解后才有意义）</pre>
<pre>（3）分支限界法首先确定一个合理的限界函数，并根据限界函数确定目标函数的界[down, up]；然后按照广度优先策略遍历问题的解空间树，在某一分支上，依次搜索该结点的所有孩子结点，分别估算这些孩子结点的目标函数的可能取值（对最小化问题，估算结点的down，对最大化问题，估算结点的up）。如果某孩子结点的目标函数值超出目标函数的界，则将其丢弃（从此结点生成的解不会比目前已得的更好），否则入待处理表。</pre>
<pre><strong>分支限界法的设计思路</strong></pre>
<pre>设求解最大化问题，解向量为X=(x1,…,xn)，xi的取值范围为Si，|Si|=ri。在使用分支限界搜索问题的解空间树时，先根据限界函数估算目标函数的界[down, up]，然后从根结点出发，扩展根结点的r1个孩子结点，从而构成分量x1的r1种可能的取值方式。</pre>
<pre>对这r1个孩子结点分别估算可能的目标函数bound(x1)，其含义：以该结点为根的子树所有可能的取值不大于bound(x1)，即：</pre>
<pre>bound(x1)≥bound(x1,x2)≥…≥ bound(x1,…,xn)</pre>
<pre>若某孩子结点的目标函数值超出目标函数的下界，则将该孩子结点丢弃；否则，将该孩子结点保存在待处理结点表PT中。</pre>
<pre>再取PT表中目标函数极大值结点作为扩展的根结点，重复上述。</pre>
<pre>直到一个叶子结点时的可行解X=(x1,…,xn)，及目标函数值bound(x1,…,xn)。</pre>
<pre><strong>分支限界法应用：1.</strong>分支限界法之装载问题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;2. 分支限界法之布线问题 </pre>
<pre>3. 分支限界法之0 1背包问题 4. 分支限界法之旅行售货员问题</pre>
<pre>整理参考：<a href="http://c.chinaitlab.com/special/algorithm/Index.html" target="_blank">http://c.chinaitlab.com/special/algorithm/Index.html</a> </pre>
<p>&nbsp;</p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory">分类: <a href="https://www.cnblogs.com/lsgxeva/category/1106301.html" target="_blank">DataStructure</a></div>
<div id="EntryTag"></div>
<div id="blog_post_info"><div id="green_channel">
        <a href="javascript:void(0);" id="green_channel_digg" onclick="DiggIt(7800564,cb_blogId,1);green_channel_success(this,&#39;谢谢推荐！&#39;);">好文要顶</a>
            <a id="green_channel_follow" onclick="follow(&#39;f7fcc9f7-9077-e511-9fc1-ac853d9f53cc&#39;);" href="javascript:void(0);">关注我</a>
    <a id="green_channel_favorite" onclick="AddToWz(cb_entryId);return false;" href="javascript:void(0);">收藏该文</a>
    <a id="green_channel_weibo" href="javascript:void(0);" title="分享至新浪微博" onclick="ShareToTsina()"><img src="./算法设计之五大常用算法设计方法总结 - lsgxeva - 博客园_files/icon_weibo_24.png" alt=""></a>
    <a id="green_channel_wechat" href="javascript:void(0);" title="分享至微信" onclick="shareOnWechat()"><img src="./算法设计之五大常用算法设计方法总结 - lsgxeva - 博客园_files/wechat.png" alt=""></a>
</div>
<div id="author_profile">
    <div id="author_profile_info" class="author_profile_info">
            <a href="http://home.cnblogs.com/u/lsgxeva/" target="_blank"><img src="./算法设计之五大常用算法设计方法总结 - lsgxeva - 博客园_files/20171110125101.png" class="author_avatar" alt=""></a>
        <div id="author_profile_detail" class="author_profile_info">
            <a href="http://home.cnblogs.com/u/lsgxeva/">lsgxeva</a><br>
            <a href="http://home.cnblogs.com/u/lsgxeva/followees">关注 - 0</a><br>
            <a href="http://home.cnblogs.com/u/lsgxeva/followers">粉丝 - 35</a>
        </div>
    </div>
    <div class="clear"></div>
    <div id="author_profile_honor"></div>
    <div id="author_profile_follow">
                <a href="javascript:void(0);" onclick="follow(&#39;f7fcc9f7-9077-e511-9fc1-ac853d9f53cc&#39;);return false;">+加关注</a>
    </div>
</div>
<div id="div_digg">
    <div class="diggit" onclick="votePost(7800564,&#39;Digg&#39;)">
        <span class="diggnum" id="digg_count">0</span>
    </div>
    <div class="buryit" onclick="votePost(7800564,&#39;Bury&#39;)">
        <span class="burynum" id="bury_count">0</span>
    </div>
    <div class="clear"></div>
    <div class="diggword" id="digg_tips">
    </div>
</div>
<script type="text/javascript">
    currentDiggType = 0;
</script></div>
<div class="clear"></div>
<div id="post_next_prev"><a href="https://www.cnblogs.com/lsgxeva/p/7800405.html" class="p_n_p_prefix">« </a> 上一篇：<a href="https://www.cnblogs.com/lsgxeva/p/7800405.html" title="发布于2017-11-07 18:29">超计算（Hyper computation）模型</a><br><a href="https://www.cnblogs.com/lsgxeva/p/7800583.html" class="p_n_p_prefix">» </a> 下一篇：<a href="https://www.cnblogs.com/lsgxeva/p/7800583.html" title="发布于2017-11-07 19:10">算法的时间复杂度和空间复杂度-总结</a><br></div>
</div>


		</div>
		<div class="postDesc">posted @ <span id="post-date">2017-11-07 19:06</span> <a href="https://www.cnblogs.com/lsgxeva/">lsgxeva</a> 阅读(<span id="post_view_count">5112</span>) 评论(<span id="post_comment_count">0</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7800564" rel="nofollow">编辑</a> <a href="https://www.cnblogs.com/lsgxeva/p/7800564.html#" onclick="AddToWz(7800564);return false;">收藏</a></div>
	</div>
	<script type="text/javascript">var allowComments=true,cb_blogId=250005,cb_entryId=7800564,cb_blogApp=currentBlogApp,cb_blogUserGuid='f7fcc9f7-9077-e511-9fc1-ac853d9f53cc',cb_entryCreatedDate='2017/11/7 19:06:00';loadViewCount(cb_entryId);var cb_postType=1;var isMarkdown=false;</script>
	
</div><!--end: topics 文章、评论容器-->
</div><a name="!comments"></a><div id="blog-comments-placeholder"></div><script type="text/javascript">var commentManager = new blogCommentManager();commentManager.renderComments(0);</script>
<div id="comment_form" class="commentform">
<a name="commentform"></a>
<div id="divCommentShow"></div>
<div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="https://www.cnblogs.com/lsgxeva/p/7800564.html#" onclick="return RefreshPage();">刷新页面</a><a href="https://www.cnblogs.com/lsgxeva/p/7800564.html#top">返回顶部</a></div>
<div id="comment_form_container"><div class="login_tips">注册用户登录后才能发表评论，请 <a rel="nofollow" href="javascript:void(0);" class="underline" onclick="return login(&#39;commentform&#39;);">登录</a> 或 <a rel="nofollow" href="javascript:void(0);" class="underline" onclick="return register();">注册</a>，<a href="http://www.cnblogs.com/">访问</a>网站首页。</div></div>
<div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
<div id="ad_t2"><a href="http://www.ucancode.com/index.htm" target="_blank" onclick="ga(&#39;send&#39;, &#39;event&#39;, &#39;Link&#39;, &#39;click&#39;, &#39;T2-工控&#39;)">【推荐】 全源码开放:大型组态\工控\监控电力仿真CAD免费下载2019！</a><br><a href="https://gitee.com/enterprises?from=bky-2" target="_blank" onclick="ga(&#39;send&#39;, &#39;event&#39;, &#39;Link&#39;, &#39;click&#39;, &#39;T2-gitee&#39;)">【推荐】专业便捷的企业级代码托管服务 - Gitee 码云</a><br></div>
<div id="opt_under_post"></div>
<script async="async" src="./算法设计之五大常用算法设计方法总结 - lsgxeva - 博客园_files/gpt.js"></script>
<script>
  var googletag = googletag || {};
  googletag.cmd = googletag.cmd || [];
</script>
<script>
  googletag.cmd.push(function() {
        googletag.defineSlot('/1090369/C1', [300, 250], 'div-gpt-ad-1546353474406-0').addService(googletag.pubads());
        googletag.defineSlot('/1090369/C2', [468, 60], 'div-gpt-ad-1539008685004-0').addService(googletag.pubads());
        googletag.pubads().enableSingleRequest();
        googletag.enableServices();
  });
</script>
<div id="cnblogs_c1" class="c_ad_block">
    <div id="div-gpt-ad-1546353474406-0" style="height:250px; width:300px;" data-google-query-id="COSLibGSwuACFQ-algod_pMBjQ"><div id="google_ads_iframe_/1090369/C1_0__container__" style="border: 0pt none;"><iframe id="google_ads_iframe_/1090369/C1_0" title="3rd party ad content" name="google_ads_iframe_/1090369/C1_0" width="300" height="250" scrolling="no" marginwidth="0" marginheight="0" frameborder="0" style="border: 0px; vertical-align: bottom;" data-google-container-id="1" data-load-complete="true" src="./算法设计之五大常用算法设计方法总结 - lsgxeva - 博客园_files/saved_resource.html"></iframe></div></div>
</div>
<div id="under_post_news"><div class="itnews c_ad_block"><b>相关博文：</b><br>·  <a href="https://www.cnblogs.com/harvey888/p/7074701.html" target="_blank" onclick="clickRecomItmem(7074701,&#39;s6BsHKNfz2XbXfzkYVev96KQu2nqsl436M4Nm8AkheqsSDDCjMc1MktG322kL0KzwgKql1t+q2HYevxlg3zrxiDdd7/b5xn5S2flncOYmwsu8i0Vrin1VnDX1khkwmTI8SiRU1hm6L3uDjg3rhnDh7CSMrDSmXBEENHUya1df8ZS01D+9+76UGPlwORtwLCZ&#39;)">五大常用算法</a><br>·  <a href="https://www.cnblogs.com/xk-bench/p/8392173.html" target="_blank" onclick="clickRecomItmem(8392173,&#39;Sp8v4iW1j5jikvviKMu0G1A0cuzOTJ4pRWjgnStwSLkPArxgBlc0A7/ltWtjqNJAflch0bc4LBbeaJlk6BXVnYrhz+2a5UufPO3N8cjh5041o92jmw0R9SfijlzTED5sSYeevuaItL8EVTHmF76vU8dEbmzTXsidhdjcVuRTC556sq370Xike+6ywVF9feU=&#39;)">五大常用算法：分治、动态规划、贪心、回溯和分支界定</a><br>·  <a href="https://www.cnblogs.com/trfizeng/p/4356619.html" target="_blank" onclick="clickRecomItmem(4356619,&#39;V3Ck+TVL1+QXgLbzfx8tmQcx+C4bqv27RloFkLBo1XBhd0z5cXtAo0Ui7iw295d7KmJ7X5mmn6rnsVstbuBq4dssifkXTYONoCcxZ5dLPnLXi0l9kF2l2DW8D8Xjm91uen3vLrP41Bm1p6QW4ZxNjMUMExZHOv5z+gG0Ws2fT8/FmUtZPPqgoxBPoQEH5/Fg&#39;)">分治法、动态规划、回溯法、分支界限法、贪心算法</a><br>·  <a href="https://www.cnblogs.com/liaoguifa/archive/2012/11/27/2791255.html" target="_blank" onclick="clickRecomItmem(2791255,&#39;W2aITxPCh3wvB80fIS363c+jtTqVBy9422MxNLuGwDj+QtfeVOk6sY1JmaDXZzc6I977zJl2QcCKlNs4hR9fkyYC5JiKTdNPIG9+yc/OVqNPeN7z29XfLY39+VltW2Wl9frvFvIXTR+wvyyqtmxkG936c5MDgPkR8ZpjZ14Ue5LVyEsQQle1qsrb0ejCoBKmWsPy&#39;)">SCAU 1142 巡逻的士兵 （分治）</a><br>·  <a href="https://www.cnblogs.com/roucheng/p/suanfa1.html" target="_blank" onclick="clickRecomItmem(5543188,&#39;WhWmoh89TvZVb0nykLRSYzhQD9Ncf4v7KsPyH487Si3BwpzZXq8tpZA92p3k9Lushk/QyeNlrTsIZisaIF0khxrgfIwCtsvBNX3/i51k8JSYSsuo+0aIjCzvtQuMO9KOjccDTXl4GGthzqi0D20GlT+t34mzncDjYX3IWLLibm4i3qu4zH9upsEtzUgEMZy8&#39;)">五大常用算法之一：分治算法</a><br></div></div>
<div id="cnblogs_c2" class="c_ad_block">
    <div id="div-gpt-ad-1539008685004-0" style="height:60px; width:468px;" data-google-query-id="CJHmh7GSwuACFYKelgod8vAHzw"><div id="google_ads_iframe_/1090369/C2_0__container__" style="border: 0pt none;"><iframe id="google_ads_iframe_/1090369/C2_0" title="3rd party ad content" name="google_ads_iframe_/1090369/C2_0" width="468" height="60" scrolling="no" marginwidth="0" marginheight="0" frameborder="0" data-google-container-id="2" style="border: 0px; vertical-align: bottom;" data-load-complete="true" src="./算法设计之五大常用算法设计方法总结 - lsgxeva - 博客园_files/saved_resource(1).html"></iframe></div></div>
</div>
<div id="under_post_kb"><div class="itnews c_ad_block"><b>最新新闻</b>：<br> ·  <a href="https://news.cnblogs.com/n/619626/" target="_blank">先南下再西游，蚂蚁金服的海外投资如何开花？</a><br> ·  <a href="https://news.cnblogs.com/n/619625/" target="_blank">2019年，如何让你的收入潜力成倍提高？</a><br> ·  <a href="https://news.cnblogs.com/n/619624/" target="_blank">Google Jib即将迎来正式版</a><br> ·  <a href="https://news.cnblogs.com/n/619623/" target="_blank">苹果挖来微软元老级高管负责智能家居 欲赶超谷歌亚马逊</a><br> ·  <a href="https://news.cnblogs.com/n/619622/" target="_blank">坐Google无人驾驶车通勤是什么体验？道路千万条，安全第一条</a><br>» <a href="http://news.cnblogs.com/" title="IT新闻" target="_blank">更多新闻...</a></div></div>
<div id="HistoryToday" class="c_ad_block"></div>
<script type="text/javascript">
 if(enablePostBottom()) {
    codeHighlight();
    fixPostBody();
    setTimeout(function () { incrementViewCount(cb_entryId); }, 50);
    deliverT2();
    deliverC1();
    deliverC2();    
    loadNewsAndKb();
    loadBlogSignature();
    LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
    GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
    loadOptUnderPost();
    GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);  
}
</script>
</div>

    
	</div><!--end: forFlow -->
	</div><!--end: mainContent 主体内容容器-->

	<div id="sideBar">
		<div id="sideBarMain">
			
<!--done-->
<div class="newsItem">
<h3 class="catListTitle">公告</h3>
	<div id="blog-news"><div id="profile_block">昵称：<a href="https://home.cnblogs.com/u/lsgxeva/">lsgxeva</a><br>园龄：<a href="https://home.cnblogs.com/u/lsgxeva/" title="入园时间：2015-10-21">3年3个月</a><br>粉丝：<a href="https://home.cnblogs.com/u/lsgxeva/followers/">35</a><br>关注：<a href="https://home.cnblogs.com/u/lsgxeva/followees/">0</a><div id="p_b_follow"><a href="javascript:void(0);" onclick="follow(&#39;f7fcc9f7-9077-e511-9fc1-ac853d9f53cc&#39;)">+加关注</a></div><script>getFollowStatus('f7fcc9f7-9077-e511-9fc1-ac853d9f53cc')</script></div></div><script type="text/javascript">loadBlogNews();</script>
</div>

			<div id="blog-calendar" style=""><table id="blogCalendar" class="Cal" cellspacing="0" cellpadding="0" title="Calendar">
	<tbody><tr><td colspan="7"><table class="CalTitle" cellspacing="0">
		<tbody><tr><td class="CalNextPrev"><a href="javascript:void(0);" onclick="loadBlogCalendar(&#39;2019/01/01&#39;);return false;">&lt;</a></td><td align="center">2019年2月</td><td class="CalNextPrev" align="right"><a href="javascript:void(0);" onclick="loadBlogCalendar(&#39;2019/03/01&#39;);return false;">&gt;</a></td></tr>
	</tbody></table></td></tr><tr><th class="CalDayHeader" align="center" abbr="日" scope="col">日</th><th class="CalDayHeader" align="center" abbr="一" scope="col">一</th><th class="CalDayHeader" align="center" abbr="二" scope="col">二</th><th class="CalDayHeader" align="center" abbr="三" scope="col">三</th><th class="CalDayHeader" align="center" abbr="四" scope="col">四</th><th class="CalDayHeader" align="center" abbr="五" scope="col">五</th><th class="CalDayHeader" align="center" abbr="六" scope="col">六</th></tr><tr><td class="CalOtherMonthDay" align="center">27</td><td class="CalOtherMonthDay" align="center">28</td><td class="CalOtherMonthDay" align="center">29</td><td class="CalOtherMonthDay" align="center">30</td><td class="CalOtherMonthDay" align="center">31</td><td align="center">1</td><td class="CalWeekendDay" align="center">2</td></tr><tr><td class="CalWeekendDay" align="center"><a href="https://www.cnblogs.com/lsgxeva/archive/2019/02/03.html"><u>3</u></a></td><td align="center">4</td><td align="center">5</td><td align="center">6</td><td align="center">7</td><td align="center">8</td><td class="CalWeekendDay" align="center">9</td></tr><tr><td class="CalWeekendDay" align="center">10</td><td align="center"><a href="https://www.cnblogs.com/lsgxeva/archive/2019/02/11.html"><u>11</u></a></td><td align="center"><a href="https://www.cnblogs.com/lsgxeva/archive/2019/02/12.html"><u>12</u></a></td><td align="center"><a href="https://www.cnblogs.com/lsgxeva/archive/2019/02/13.html"><u>13</u></a></td><td align="center">14</td><td align="center"><a href="https://www.cnblogs.com/lsgxeva/archive/2019/02/15.html"><u>15</u></a></td><td class="CalWeekendDay" align="center">16</td></tr><tr><td class="CalTodayDay" align="center">17</td><td align="center">18</td><td align="center">19</td><td align="center">20</td><td align="center">21</td><td align="center">22</td><td class="CalWeekendDay" align="center">23</td></tr><tr><td class="CalWeekendDay" align="center">24</td><td align="center">25</td><td align="center">26</td><td align="center">27</td><td align="center">28</td><td class="CalOtherMonthDay" align="center">1</td><td class="CalOtherMonthDay" align="center">2</td></tr><tr><td class="CalOtherMonthDay" align="center">3</td><td class="CalOtherMonthDay" align="center">4</td><td class="CalOtherMonthDay" align="center">5</td><td class="CalOtherMonthDay" align="center">6</td><td class="CalOtherMonthDay" align="center">7</td><td class="CalOtherMonthDay" align="center">8</td><td class="CalOtherMonthDay" align="center">9</td></tr>
</tbody></table></div><script type="text/javascript">loadBlogDefaultCalendar();</script>
			
			<div id="leftcontentcontainer">
				<div id="blog-sidecolumn"><div id="sidebar_search" class="sidebar-block">
<div id="sidebar_search" class="mySearch">
<h3 class="catListTitle">搜索</h3>
<div id="sidebar_search_box">
<div id="widget_my_zzk" class="div_my_zzk"><input type="text" id="q" onkeydown="return zzk_go_enter(event);" class="input_my_zzk">&nbsp;<input onclick="zzk_go()" type="button" value="找找看" id="btnZzk" class="btn_my_zzk"></div>
<div id="widget_my_google" class="div_my_zzk"><input type="text" name="google_q" id="google_q" onkeydown="return google_go_enter(event)" class="input_my_zzk">&nbsp;<input onclick="google_go()" type="button" value="谷歌搜索" class="btn_my_zzk"></div>
</div>
</div>

</div><div id="sidebar_shortcut" class="sidebar-block">
<div class="catListLink">
<h3 class="catListTitle">常用链接</h3>
<ul>
<li><a href="https://www.cnblogs.com/lsgxeva/p/" title="我的博客的随笔列表">我的随笔</a></li><li><a href="https://www.cnblogs.com/lsgxeva/MyComments.html" title="我发表过的评论列表">我的评论</a></li><li><a href="https://www.cnblogs.com/lsgxeva/OtherPosts.html" title="我评论过的随笔列表">我的参与</a></li><li><a href="https://www.cnblogs.com/lsgxeva/RecentComments.html" title="我的博客的评论列表">最新评论</a></li><li><a href="https://www.cnblogs.com/lsgxeva/tag/" title="我的博客的标签列表">我的标签</a></li>
</ul>
<div id="itemListLin_con" style="display:none;">
<ul>

</ul>
</div>
</div></div><div id="sidebar_toptags" class="sidebar-block"></div><div id="sidebar_categories">
<div id="sidebar_postcategory" class="catListPostCategory sidebar-block">
<h3 class="catListTitle">随笔分类</h3>

<ul>

<li><a id="CatList_LinkList_0_Link_0" href="https://www.cnblogs.com/lsgxeva/category/1236843.html">a10(4)</a> </li>

<li><a id="CatList_LinkList_0_Link_1" href="https://www.cnblogs.com/lsgxeva/category/1272090.html">AI(1)</a> </li>

<li><a id="CatList_LinkList_0_Link_2" href="https://www.cnblogs.com/lsgxeva/category/1124742.html">algorithm(1)</a> </li>

<li><a id="CatList_LinkList_0_Link_3" href="https://www.cnblogs.com/lsgxeva/category/1107738.html">Android</a> </li>

<li><a id="CatList_LinkList_0_Link_4" href="https://www.cnblogs.com/lsgxeva/category/1186832.html">ans(21)</a> </li>

<li><a id="CatList_LinkList_0_Link_5" href="https://www.cnblogs.com/lsgxeva/category/1273697.html">BIG-IP</a> </li>

<li><a id="CatList_LinkList_0_Link_6" href="https://www.cnblogs.com/lsgxeva/category/1089370.html">c++(65)</a> </li>

<li><a id="CatList_LinkList_0_Link_7" href="https://www.cnblogs.com/lsgxeva/category/1107731.html">c++11(32)</a> </li>

<li><a id="CatList_LinkList_0_Link_8" href="https://www.cnblogs.com/lsgxeva/category/1106300.html">cmake(4)</a> </li>

<li><a id="CatList_LinkList_0_Link_9" href="https://www.cnblogs.com/lsgxeva/category/1274593.html">cocos(1)</a> </li>

<li><a id="CatList_LinkList_0_Link_10" href="https://www.cnblogs.com/lsgxeva/category/1106568.html">CSharp(12)</a> </li>

<li><a id="CatList_LinkList_0_Link_11" href="https://www.cnblogs.com/lsgxeva/category/1106301.html">DataStructure(6)</a> </li>

<li><a id="CatList_LinkList_0_Link_12" href="https://www.cnblogs.com/lsgxeva/category/1106302.html">DesignPattern(39)</a> </li>

<li><a id="CatList_LinkList_0_Link_13" href="https://www.cnblogs.com/lsgxeva/category/1370369.html">donet(1)</a> </li>

<li><a id="CatList_LinkList_0_Link_14" href="https://www.cnblogs.com/lsgxeva/category/1290704.html">eve-ng(4)</a> </li>

<li><a id="CatList_LinkList_0_Link_15" href="https://www.cnblogs.com/lsgxeva/category/1124648.html">exam(4)</a> </li>

<li><a id="CatList_LinkList_0_Link_16" href="https://www.cnblogs.com/lsgxeva/category/1349303.html">FortiGate(14)</a> </li>

<li><a id="CatList_LinkList_0_Link_17" href="https://www.cnblogs.com/lsgxeva/category/1147638.html">fpga(1)</a> </li>

<li><a id="CatList_LinkList_0_Link_18" href="https://www.cnblogs.com/lsgxeva/category/1086425.html">gcc(12)</a> </li>

<li><a id="CatList_LinkList_0_Link_19" href="https://www.cnblogs.com/lsgxeva/category/1149335.html">Hacker(24)</a> </li>

<li><a id="CatList_LinkList_0_Link_20" href="https://www.cnblogs.com/lsgxeva/category/1129417.html">ios</a> </li>

<li><a id="CatList_LinkList_0_Link_21" href="https://www.cnblogs.com/lsgxeva/category/1107737.html">Java(46)</a> </li>

<li><a id="CatList_LinkList_0_Link_22" href="https://www.cnblogs.com/lsgxeva/category/1362977.html">Juila(1)</a> </li>

<li><a id="CatList_LinkList_0_Link_23" href="https://www.cnblogs.com/lsgxeva/category/1132576.html">Linux(75)</a> </li>

<li><a id="CatList_LinkList_0_Link_24" href="https://www.cnblogs.com/lsgxeva/category/1086426.html">llvm</a> </li>

<li><a id="CatList_LinkList_0_Link_25" href="https://www.cnblogs.com/lsgxeva/category/1106298.html">lua(29)</a> </li>

<li><a id="CatList_LinkList_0_Link_26" href="https://www.cnblogs.com/lsgxeva/category/1134162.html">niaoyun(12)</a> </li>

<li><a id="CatList_LinkList_0_Link_27" href="https://www.cnblogs.com/lsgxeva/category/1106297.html">nodejs(56)</a> </li>

<li><a id="CatList_LinkList_0_Link_28" href="https://www.cnblogs.com/lsgxeva/category/1128582.html">ns(138)</a> </li>

<li><a id="CatList_LinkList_0_Link_29" href="https://www.cnblogs.com/lsgxeva/category/1253838.html">powershell(6)</a> </li>

<li><a id="CatList_LinkList_0_Link_30" href="https://www.cnblogs.com/lsgxeva/category/1106403.html">Python(1)</a> </li>

<li><a id="CatList_LinkList_0_Link_31" href="https://www.cnblogs.com/lsgxeva/category/1106299.html">QT(33)</a> </li>

<li><a id="CatList_LinkList_0_Link_32" href="https://www.cnblogs.com/lsgxeva/category/1148667.html">Rust(7)</a> </li>

<li><a id="CatList_LinkList_0_Link_33" href="https://www.cnblogs.com/lsgxeva/category/1266871.html">sangforAD(2)</a> </li>

<li><a id="CatList_LinkList_0_Link_34" href="https://www.cnblogs.com/lsgxeva/category/1272089.html">Scheme(52)</a> </li>

<li><a id="CatList_LinkList_0_Link_35" href="https://www.cnblogs.com/lsgxeva/category/1369666.html">SICP(1)</a> </li>

<li><a id="CatList_LinkList_0_Link_36" href="https://www.cnblogs.com/lsgxeva/category/1107727.html">STL(16)</a> </li>

<li><a id="CatList_LinkList_0_Link_37" href="https://www.cnblogs.com/lsgxeva/category/1124282.html">TCP/IP(8)</a> </li>

<li><a id="CatList_LinkList_0_Link_38" href="https://www.cnblogs.com/lsgxeva/category/1106567.html">unity3d(4)</a> </li>

</ul>

</div>

<div id="sidebar_postarchive" class="catListPostArchive sidebar-block">
<h3 class="catListTitle">随笔档案</h3>

<ul>

<li><a id="CatList_LinkList_1_Link_0" href="https://www.cnblogs.com/lsgxeva/archive/2019/02.html">2019年2月 (12)</a> </li>

<li><a id="CatList_LinkList_1_Link_1" href="https://www.cnblogs.com/lsgxeva/archive/2019/01.html">2019年1月 (43)</a> </li>

<li><a id="CatList_LinkList_1_Link_2" href="https://www.cnblogs.com/lsgxeva/archive/2018/12.html">2018年12月 (49)</a> </li>

<li><a id="CatList_LinkList_1_Link_3" href="https://www.cnblogs.com/lsgxeva/archive/2018/11.html">2018年11月 (30)</a> </li>

<li><a id="CatList_LinkList_1_Link_4" href="https://www.cnblogs.com/lsgxeva/archive/2018/10.html">2018年10月 (18)</a> </li>

<li><a id="CatList_LinkList_1_Link_5" href="https://www.cnblogs.com/lsgxeva/archive/2018/09.html">2018年9月 (21)</a> </li>

<li><a id="CatList_LinkList_1_Link_6" href="https://www.cnblogs.com/lsgxeva/archive/2018/08.html">2018年8月 (36)</a> </li>

<li><a id="CatList_LinkList_1_Link_7" href="https://www.cnblogs.com/lsgxeva/archive/2018/07.html">2018年7月 (43)</a> </li>

<li><a id="CatList_LinkList_1_Link_8" href="https://www.cnblogs.com/lsgxeva/archive/2018/06.html">2018年6月 (35)</a> </li>

<li><a id="CatList_LinkList_1_Link_9" href="https://www.cnblogs.com/lsgxeva/archive/2018/05.html">2018年5月 (15)</a> </li>

<li><a id="CatList_LinkList_1_Link_10" href="https://www.cnblogs.com/lsgxeva/archive/2018/04.html">2018年4月 (42)</a> </li>

<li><a id="CatList_LinkList_1_Link_11" href="https://www.cnblogs.com/lsgxeva/archive/2018/03.html">2018年3月 (33)</a> </li>

<li><a id="CatList_LinkList_1_Link_12" href="https://www.cnblogs.com/lsgxeva/archive/2018/02.html">2018年2月 (25)</a> </li>

<li><a id="CatList_LinkList_1_Link_13" href="https://www.cnblogs.com/lsgxeva/archive/2018/01.html">2018年1月 (32)</a> </li>

<li><a id="CatList_LinkList_1_Link_14" href="https://www.cnblogs.com/lsgxeva/archive/2017/12.html">2017年12月 (92)</a> </li>

<li><a id="CatList_LinkList_1_Link_15" href="https://www.cnblogs.com/lsgxeva/archive/2017/11.html">2017年11月 (129)</a> </li>

<li><a id="CatList_LinkList_1_Link_16" href="https://www.cnblogs.com/lsgxeva/archive/2017/10.html">2017年10月 (72)</a> </li>

<li><a id="CatList_LinkList_1_Link_17" href="https://www.cnblogs.com/lsgxeva/archive/2017/09.html">2017年9月 (7)</a> </li>

</ul>

</div>

</div><div id="sidebar_recentcomments" class="sidebar-block"><div id="recent_comments_wrap">
<div class="catListComment">
<h3 class="catListTitle">最新评论</h3>

	<div id="RecentCommentsBlock"><ul>
        <li class="recent_comment_title"><a href="https://www.cnblogs.com/lsgxeva/p/7758184.html#4180648">1. Re:babel从入门到入门</a></li>
        <li class="recent_comment_body">写的非常好</li>
        <li class="recent_comment_author">--Zeroes</li>
        <li class="recent_comment_title"><a href="https://www.cnblogs.com/lsgxeva/p/7976026.html#4169190">2. Re:JS执行上下文(执行环境)详细图解</a></li>
        <li class="recent_comment_body">最后一个例子f2执行了，应该是入栈了吧</li>
        <li class="recent_comment_author">--魏晶晶</li>
        <li class="recent_comment_title"><a href="https://www.cnblogs.com/lsgxeva/p/10153751.html#4158444">3. Re:MIT Scheme 的基本使用</a></li>
        <li class="recent_comment_body">@小胖西瓜MIT scheme 这个是 scheme编程语言的一个简单的IDE环境，可以在进行repl操作和在edwin中调用scheme解释器。在 emacs 中可以设置在指定模式下调用 MIT-G......</li>
        <li class="recent_comment_author">--lsgxeva</li>
        <li class="recent_comment_title"><a href="https://www.cnblogs.com/lsgxeva/p/10153751.html#4155021">4. Re:MIT Scheme 的基本使用</a></li>
        <li class="recent_comment_body">老哥 你这个和scheme有关系吗 这不是emacs的使用吗</li>
        <li class="recent_comment_author">--小胖西瓜</li>
        <li class="recent_comment_title"><a href="https://www.cnblogs.com/lsgxeva/p/7787478.html#4137767">5. Re:c++11 函数模板的默认模板参数</a></li>
        <li class="recent_comment_body">最后两个是声明吧，我在vs2017中可以通过编译。这里有个问题，可以看到第3条，c++98不能通过编译那个，定义函数模板时，最后}后是不加分号的，同样可参看1.但是若只声明，如最后两个，则}后是要加分......</li>
        <li class="recent_comment_author">--超声信号处理</li>
</ul>
</div>
</div>
</div></div><div id="sidebar_topviewedposts" class="sidebar-block"><div id="topview_posts_wrap">
<div class="catListView">
<h3 class="catListTitle">阅读排行榜</h3>
	<div id="TopViewPostsBlock"><ul><li><a href="https://www.cnblogs.com/lsgxeva/p/8746644.html">1. Docker 创建镜像、修改、上传镜像(12258)</a></li><li><a href="https://www.cnblogs.com/lsgxeva/p/7807029.html">2. Qt基本控件及三大布局(12189)</a></li><li><a href="https://www.cnblogs.com/lsgxeva/p/8540758.html">3. Git Submodule使用完整教程(9720)</a></li><li><a href="https://www.cnblogs.com/lsgxeva/p/7821550.html">4. QT 基本图形绘制(9093)</a></li><li><a href="https://www.cnblogs.com/lsgxeva/p/8280224.html">5. JAVA 基础开发环境 vscode 搭建 Windows下VSCode编译运行简单java(8587)</a></li></ul></div>
</div>
</div></div><div id="sidebar_topcommentedposts" class="sidebar-block"><div id="topfeedback_posts_wrap">
<div class="catListFeedback">
<h3 class="catListTitle">评论排行榜</h3>
	<div id="TopFeedbackPostsBlock"><ul><li><a href="https://www.cnblogs.com/lsgxeva/p/7758184.html">1. babel从入门到入门(4)</a></li><li><a href="https://www.cnblogs.com/lsgxeva/p/10153751.html">2. MIT Scheme 的基本使用(2)</a></li><li><a href="https://www.cnblogs.com/lsgxeva/p/7976026.html">3. JS执行上下文(执行环境)详细图解(1)</a></li><li><a href="https://www.cnblogs.com/lsgxeva/p/7788259.html">4. c++11 闭包的实现(1)</a></li><li><a href="https://www.cnblogs.com/lsgxeva/p/7787478.html">5. c++11 函数模板的默认模板参数(1)</a></li></ul></div>
</div>
</div></div><div id="sidebar_topdiggedposts" class="sidebar-block"><div id="topdigg_posts_wrap">
<div class="catListView">
<h3 class="catListTitle">推荐排行榜</h3>
<div id="TopDiggPostsBlock"><ul><li><a href="https://www.cnblogs.com/lsgxeva/p/7758184.html">1. babel从入门到入门(4)</a></li><li><a href="https://www.cnblogs.com/lsgxeva/p/7976263.html">2. react 入门与进阶教程(2)</a></li><li><a href="https://www.cnblogs.com/lsgxeva/p/7944986.html">3. VS2017常用快快捷键(1)</a></li><li><a href="https://www.cnblogs.com/lsgxeva/p/7910509.html">4. 修改gcc/g++默认include路径(1)</a></li><li><a href="https://www.cnblogs.com/lsgxeva/p/7858363.html">5. Win10 安装 Linux 子系统(1)</a></li></ul></div>
</div></div></div></div><script type="text/javascript">loadBlogSideColumn();</script>
			</div>
			
		</div><!--end: sideBarMain -->
	</div><!--end: sideBar 侧边栏容器 -->
	<div class="clear"></div>
	</div><!--end: main -->
	<div class="clear"></div>
	<div id="footer">
		
<!--done-->
Copyright ©2019 lsgxeva
	</div><!--end: footer -->
</div><!--end: home 自定义的最大容器 -->



<iframe id="google_osd_static_frame_484958805758" name="google_osd_static_frame" style="display: none; width: 0px; height: 0px;" src="./算法设计之五大常用算法设计方法总结 - lsgxeva - 博客园_files/saved_resource(2).html"></iframe></body></html>